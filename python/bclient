#!/usr/bin/env python

# Copyright (c) 2017 Open Grid Computing, Inc. All rights reserved.
# Copyright (c) 2017 Sandia Corporation. All rights reserved.
#
# Under the terms of Contract DE-AC04-94AL85000, there is a non-exclusive
# license for use of this work by or on behalf of the U.S. Government.
# Export of this program may require a license from the United States
# Government.
#
# This software is available to you under a choice of one of two
# licenses.  You may choose to be licensed under the terms of the GNU
# General Public License (GPL) Version 2, available from the file
# COPYING in the main directory of this source tree, or the BSD-type
# license below:
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#      Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#      Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials provided
#      with the distribution.
#
#      Neither the name of Sandia nor the names of any contributors may
#      be used to endorse or promote products derived from this software
#      without specific prior written permission.
#
#      Neither the name of Open Grid Computing nor the names of any
#      contributors may be used to endorse or promote products derived
#      from this software without specific prior written permission.
#
#      Modified source versions must be plainly marked as such, and
#      must not be misrepresented as being the original software.
#
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os
import cmd
import logging
import shlex
import re
import datetime
import sys
import curses
import collections
from baler import Bq
from baler import util
from io import StringIO

logger = logging.getLogger(__name__)

store = None

# This is the class for global debug object.
class Debug(object): pass

# Global debug object.
DEBUG = Debug()

FWD = 1
REV = 2


def open_store(path, plugin = "bstore_sos", **kwargs):
    """Open the baler store at `path`."""
    global store
    store = Bq.Bstore(plugin)
    store.open(path)


class CmdException(Exception):
    pass


class CmdArgumentParser(object):
    def __init__(self, *args):
        """Initialize a command argument parser.

        Args:
            arg_spec: [(name, type, value_hint, bool, default)] - a list of
                        5-tuple describing argument's name, type, value hint,
                        if the argument is required, and the default value
                        respectively.
        """
        self.kwargs_type = {}
        self.kwargs_hint = {}
        self.default_value = {}
        self.required_kwargs = []
        self.available_kwargs = set()
        for (_name, _type, _hint, _required, _default) in args:
            self.default_value[_name] = _default
            self.kwargs_type[_name] = _type
            self.kwargs_hint[_name] = _hint
            self.available_kwargs.add(_name)
            if _required:
                self.required_kwargs.append(_name)

    def parse(self, arg=str()):
        """Parse the command arguments.

        Returns:
            tuple(map(), list()) for keyword arguments and positional
                        arguments respectively. The keywoard argument map will
                        also contain optional arguments with value `None` if the
                        option is not given. This is to conveniently avoid
                        `KeyError` exception.
        """
        _kwargs = {}
        _args = []
        for a in shlex.split(arg):
            x = a.split('=', 1)
            if len(x) == 1:
                # positional arg
                _args.append(a)
            else:
                # check if keyword is valid
                if x[0] not in self.available_kwargs:
                    raise CmdException("Invalid keyword: %s" % x[0])
                _kwargs[x[0]] = self.kwargs_type[x[0]](x[1])
        for kw in self.required_kwargs:
            if kw not in _kwargs:
                raise CmdException("Required keyword not specified: %s" % kw)
        for kw in self.available_kwargs:
            if kw not in _kwargs:
                _kwargs[kw] = self.default_value[kw]
        return (_kwargs, _args)

## ---- CmdArgumentParser ---- ##


class FakeIterator():
    def __init__(self, begin=0, end=1000):
        self._begin = begin
        self._end = end
        self.current = self._begin - 1

    def next(self):
        if self.current >= self._end:
            return None
        if self.current < self._begin:
            self.current = self._begin - 1
        self.current += 1
        return self.current

    def prev(self):
        if self.current <= self._begin:
            return None
        if self.current > self._end:
            self.current = self._end + 1
        self.current -= 1
        return self.current

    def get_pos(self):
        return self.current

    def set_pos(self, pos):
        self.current = pos


class PageDisplay(object):
    def __init__(self, itr, formatter=str):
        self.itr = itr
        self.active = True
        self.dir = None
        self.formatter = formatter
        self.offset = 0
        self.maxoffset = 0
        self.a2c_rex = re.compile("(\\d+)(?:m|;)")
        self.c_rex = re.compile("(\033\\[[^m]+m)|([^\033]*)")
        # init buffer
        self.buff = collections.deque()

    def _start(self):
        self.win = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.start_color()
        curses.use_default_colors()
        # setup color pairs
        curses.init_pair(1, curses.COLOR_RED, -1)
        curses.init_pair(2, curses.COLOR_GREEN, -1)
        curses.init_pair(3, curses.COLOR_YELLOW, -1)
        curses.init_pair(4, curses.COLOR_BLUE, -1)
        curses.init_pair(5, curses.COLOR_MAGENTA, -1)
        curses.init_pair(6, curses.COLOR_CYAN, -1)
        curses.init_pair(7, curses.COLOR_WHITE, -1)
        self.a2c_table = {
                    0: 0,
                    1: curses.A_BOLD,
                    4: curses.A_UNDERLINE,
                    30: 0,
                    31: curses.color_pair(1),
                    32: curses.color_pair(2),
                    33: curses.color_pair(3),
                    34: curses.color_pair(4),
                    35: curses.color_pair(5),
                    36: curses.color_pair(6),
                    37: curses.color_pair(7),
                }
        self.active = True

    def _stop(self):
        self.active = False

    def _end(self):
        curses.nocbreak()
        curses.echo()
        curses.endwin()

    def loop(self):
        cmd_table = {
            'u': self.page_up,
            'd': self.page_down,
            'q': self._stop,
            'j': self.line_next,
            'k': self.line_prev,
            'h': self.column_left,
            'l': self.column_right,
        }
        self._start()
        try:
            self.dir = FWD
            if self.itr.first():
                item = self.itr.obj()
                pos = self.itr.get_pos()
                self.buff.append((pos, item))
            self.page_down()
            self.display_buff()
            while self.active:
                c = self.win.getkey()
                try:
                    fn = cmd_table[c]
                except KeyError:
                    continue
                fn()
                self.display_buff()
        finally:
            self._end()

    def ansi_to_curses(self, _str):
        ret = None
        for m in self.a2c_rex.finditer(_str):
            (num,) = m.groups()
            try:
                x = self.a2c_table[int(num)]
                if x == None: # reset
                    ret = None
                    continue
                if ret == None:
                    ret = x
                    continue
                c = x & 0x700
                a = x & ~0x700
                if c:
                    # replace color
                    ret = (ret & ~0x700) | c
                if a:
                    # set attribute
                    ret |= a
            except KeyError:
                pass # do nothing for the non-supported code
        return ret

    def curses_addnstr(self, r, c, _str, n, offset=0):
        attr = 0
        for m in self.c_rex.finditer(_str):
            (esc, text) = m.groups()
            if n <= 0:
                break # cannot print anymore
            if esc:
                # This is an escape sequence, change color accordingly
                attr = self.ansi_to_curses(esc)
            if text != None:
                # add text
                l = len(text)
                if offset:
                    offset -= l
                    if offset >= 0:
                        continue
                    if offset < 0:
                        text = text[offset:]
                        l = len(text)
                        offset = 0
                self.win.addnstr(r, c, text, n, attr)
                n -= l
                c += l

    def display_buff(self):
        maxy, maxx = self.getmaxyx()
        self.win.clear() # not refeshed yet
        y = 0
        # self.buff length is maxy-1
        self.maxoffset = 0
        for (pos, item) in self.buff:
            s = self.formatter(item)
            maxoffset = len(s) - maxx
            self.maxoffset = max(self.maxoffset, maxoffset)
            self.curses_addnstr(y, 0, s, maxx, self.offset)
            y += 1
        self.win.addstr(y, 0, ':(j-next_line, k-prev_line, h-left, l-right, ' +
                              'd-pg_down, u-pg_up, q-quit)')
        self.win.refresh()

    def getmaxyx(self):
        maxy, maxx = self.win.getmaxyx()
        return (maxy-1, maxx)

    def line_next(self):
        maxy, maxx = self.getmaxyx()
        if self.dir != FWD:
            # need position recovery
            (pos, item) = self.buff[len(self.buff)-1]
            self.itr.set_pos(pos)
            # replenish pos as it is once-used
            self.buff[len(self.buff)-1] = (self.itr.get_pos(), item)
            self.dir = FWD
        if not self.itr.next():
            return
        item = self.itr.obj()
        pos = self.itr.get_pos()
        self.buff.append((pos, item))
        while len(self.buff) > maxy:
            (pos, item) = self.buff.popleft()
            self.itr.put_pos(pos)
            del item

    def line_prev(self):
        maxy, maxx = self.getmaxyx()
        if self.dir != REV:
            # need position recovery
            (pos, item) = self.buff[0]
            self.itr.set_pos(pos)
            # replenish pos as it is once-used
            self.buff[0] = (self.itr.get_pos(), item)
            self.dir = REV
        if not self.itr.prev():
            return
        item = self.itr.obj()
        pos = self.itr.get_pos()
        self.buff.appendleft((pos, item))
        while len(self.buff) > maxy:
            (pos, item) = self.buff.pop()
            self.itr.put_pos(pos)
            del item

    def column_left(self):
        if self.offset:
            self.offset -= 1

    def column_right(self):
        if self.offset < self.maxoffset:
            self.offset += 1

    def page_down(self):
        maxy, maxx = self.getmaxyx()
        c = 0
        while c < (maxy - 1):
            self.line_next()
            c += 1

    def page_up(self):
        maxy, maxx = self.getmaxyx()
        c = 0
        while c < (maxy - 1):
            self.line_prev()
            c += 1


TERM_NORM = ""
TERM_BLUE = "\033[34m"
TERM_RED = "\033[31m"
TERM_GREEN = "\033[32m"
TERM_YELLOW = "\033[33m"
TERM_RESET = "\033[0m"
TERM_BOLD =  "\033[1m"
TERM_UNDERLINE = "\033[4m"


TKN_TYPE_COLORS = {
    Bq.BTKN_TYPE_TYPE        :  TERM_NORM,
    Bq.BTKN_TYPE_PRIORITY    :  TERM_NORM,
    Bq.BTKN_TYPE_VERSION     :  TERM_NORM,
    Bq.BTKN_TYPE_TIMESTAMP   :  TERM_BOLD + TERM_YELLOW,
    Bq.BTKN_TYPE_HOSTNAME    :  TERM_BOLD + TERM_GREEN,
    Bq.BTKN_TYPE_SERVICE     :  TERM_GREEN,
    Bq.BTKN_TYPE_PID         :  TERM_YELLOW,
    Bq.BTKN_TYPE_IP4_ADDR    :  TERM_NORM,
    Bq.BTKN_TYPE_IP6_ADDR    :  TERM_NORM,
    Bq.BTKN_TYPE_ETH_ADDR    :  TERM_NORM,
    Bq.BTKN_TYPE_HEX_INT     :  TERM_BOLD + TERM_BLUE,
    Bq.BTKN_TYPE_DEC_INT     :  TERM_BOLD + TERM_BLUE,
    Bq.BTKN_TYPE_FLOAT       :  TERM_BOLD + TERM_BLUE,
    Bq.BTKN_TYPE_PATH        :  TERM_BOLD + TERM_YELLOW,
    Bq.BTKN_TYPE_URL         :  TERM_BOLD + TERM_YELLOW,
    Bq.BTKN_TYPE_WORD        :  TERM_BOLD,
    Bq.BTKN_TYPE_SEPARATOR   :  TERM_NORM,
    Bq.BTKN_TYPE_WHITESPACE  :  TERM_NORM,
    Bq.BTKN_TYPE_TEXT        :  TERM_BOLD + TERM_RED,
}


def tkn_text(tkn, color=False):
    _type = tkn.first_type()
    if _type == Bq.BTKN_TYPE_TYPE:
        _type = tkn.tkn_id()
    if color:
        c = TERM_RESET
        try:
            c += TKN_TYPE_COLORS[_type]
        except KeyError:
            c += TERM_NORM
        c_end = TERM_RESET
    else:
        c = ""
        c_end = ""
    return c + tkn.ptn_tkn_str() + c_end


class PtnFormatter(object):
    def __init__(self, fmt=None, color=True):
        if not fmt:
            fmt = "%(ptn_id)s %(msg_count)s %(first_seen)s %(last_seen)s %(text)s"
        self.fmt = fmt
        self.color = color

    def __call__(self, ptn):
        return self.fmt % {
                "ptn_id": ptn.ptn_id(),
                "msg_count": ptn.msg_count(),
                "first_seen": util.Timestamp(*ptn.first_seen2()),
                "last_seen": util.Timestamp(*ptn.last_seen2()),
                "first_seen_unix": ptn.first_seen(),
                "last_seen_unix": ptn.last_seen(),
                "text": self.ptn_text(ptn),
            }

    def ptn_text(self, ptn):
        sio = StringIO()
        for tkn in ptn:
            sio.write(tkn_text(tkn, self.color))
        return sio.getvalue()


class MsgFormatter(object):
    def __init__(self, color=True):
        self.color = color

    def __call__(self, msg):
        sio = StringIO()
        ts = util.Timestamp(msg.tv_sec(), msg.tv_usec())
        sio.write(str(ts))
        sio.write(" ")
        for tkn in msg:
            sio.write(tkn_text(tkn, self.color))
        return sio.getvalue()


class ServiceCmd(cmd.Cmd):
    def __init__(self):
        cmd.Cmd.__init__(self)
        self.prompt = "bclient> "
        self.parsers = {}

    def get_parser(self, cmd):
        if cmd in self.parsers:
            return self.parsers[cmd]
        try:
            pf = getattr(self, "parser_" + cmd)
        except AttributeError:
            return None
        else:
            try:
                p = pf()
                self.parsers[cmd] = p
                return p
            except Exception as e:
                logger.debug(e)

    def parser_open(self):
        return CmdArgumentParser(
            ("path", str, "PATH", 1, None),
            ("plugin", str, "PLUGIN", 0, "bstore_sos"),
        )

    def do_open(self, arg):
        """open path=PATH [plugin=BSTORE_PLUGIN]

        Open a bstore for the current `bclient` session. The previously active
        store is closed automatically.
        """
        global store
        (kwargs, args) = (self.kwargs, self.args)
        open_store(**kwargs)

    def parser_ptn_query(self):
        return CmdArgumentParser(
            ("text", str, "REGEX", 0, None),
            ("ids", str, "RANGES", 0, None),
            ("format", str, "FMT", 0, None),
            ("order", str, "COMPARATOR", 0, "ptn_id_asc"),
        )

    def do_ptn_query(self, arg):
        """ptn_query [text=REGEX] [ids=RANGES] [format=FMT] [order=KEY_ORDER]
                     [>OUTPUT_FILE]

        Query the store for patterns that match all of the given
        conditions.

        Conditions:
            text=REGEX is the regular expression to match pattern text (e.g.
            ".*error.*").

            ids=RANGES is the comma-separated ranges to match IDs (e.g.
            "1,3-5,11").

        Optional options:
            format=FMT chooses what to print. The format is a python string, in
            which '%(field)s' will be replaced with the corresponding `field.`
            By default, the FMT is "%(ptn_id)s %(msg_count)s %(first_seen)s
            %(last_seen)s %(text)s". The available fields are:
              - ptn_id: the pattern ID,
              - msg_count: the message count in that pattern,
              - first_seen: the timestamp text of `first_seen`,
              - first_seen_unix: the seconds since epoch of `first_seen`,
              - last_seen: the timestamp text of `last_seen`,
              - last_seen_unix: the seconds since epoch of `last_seen`,

            order=COMPARATOR orders the results according to the comparator.
            Available comparators are:
              - ptn_id_asc
              - ptn_id_desc
              - tkn_count_asc
              - tkn_count_desc
              - msg_count_asc
              - msg_count_desc
              - first_seen_asc
              - first_seen_desc
              - last_seen_asc
              - last_seen_desc
              - eng_ratio, or eng_ratio_desc
              - eng_ratio_asc
            Users can implement their own comparators and put them in
            baler.ptn_cmp_ext package. Please see baler.ptn_cmp_ext.eng module
            as an example.

            >OUTPUT_FILE redirects the query results into a file (overwrite).
            Simply add `>OUTPUT_PATH` at the end of the command (OUTPUT_PATH is
            the path to the file), and the query results will be redirected
            there.
        """
        global store
        (kwargs, args) = (self.kwargs, self.args)
        text = kwargs["text"]
        ids = kwargs["ids"]
        fmt = kwargs["format"]
        order = kwargs["order"]
        if text:
            text = re.compile(text)
        if ids:
            ids = util.IDSet(ids)
        result = []
        itr = Bq.Bptn_iter(store)
        for ptn in itr:
            if ids and ptn.ptn_id() not in ids:
                continue
            if text and not text.match(str(ptn)):
                continue
            result.append(ptn)
        if order:
            _cmp = util.get_ptn_cmp_by_name(order)
            if not _cmp:
                raise CmdException("Comparator not found: \"%s\"" % order)
            result.sort(_cmp)
        color = True if self.cmdout.isatty() else False
        if self.cmdout.isatty():
            # use paging
            formatter = PtnFormatter(fmt, True)
            pager = PageDisplay(util.ListIter(result), formatter)
            pager.loop()
        else:
            formatter = PtnFormatter(fmt, False)
            for ptn in result:
                print >>self.cmdout, formatter(ptn)

    def parser_comp_query(self):
        return CmdArgumentParser(
            ("text", str, "REGEX", 0, None),
            ("ids", str, "RANGES", 0, None),
        )

    def do_comp_query(self, arg):
        """comp_query [text=REGEX] [ids=RANGES] [>OUTPUT_PATH]

        Query the store for hosts that match all of the given conditions.

        Conditions:
            text - regular expression to match host names (e.g. "node00.*").
            ids - comma-separated ranges to match IDs (e.g. "1,3-5,11").

        Optional output redirection:
            comp_query command can redirect the query results into a file
            (overwrite). Simply add `>OUTPUT_PATH` at the end of the command
            (OUTPUT_PATH is the path to the file), and the query results will be
            redirected there.
        """
        global store
        (kwargs, args) = (self.kwargs, self.args)
        text = kwargs["text"]
        ids = kwargs["ids"]
        if text:
            text = re.compile(text)
        if ids:
            ids = util.IDSet(ids)
        result = []
        itr = Bq.Btkn_iter(store)
        for h in itr:
            if h.first_type() != Bq.BTKN_TYPE_HOSTNAME:
                continue
            if ids and h.tkn_id() not in ids:
                continue
            if text and not text.match(h.tkn_str()):
                continue
            result.append((h.tkn_id(), h.tkn_str()))
        result.sort()
        for h in result:
            print >>self.cmdout, h[0], h[1]

    def do_test_paging(self, arg):
        """Test Paging"""
        itr = FakeIterator()
        p = PageDisplay(itr)
        p.loop()
        pass

    def parser_msg_query(self):
        return CmdArgumentParser(
            ("ptn_id", int, "NUM", 0, 0),
            ("comp_id", int, "NUM", 0, 0),
            ("comp_str", str, "TEXT", 0, None),
            ("begin", util.Timestamp.fromStr, "TIMESTAMP", 0,
                      util.Timestamp(0, 0)
            ),
            ("end", util.Timestamp.fromStr, "TIMESTAMP", 0,
                    util.Timestamp(0, 0)
            ),
            ("limit", int, "NUM", 0, 0)
        )

    def do_msg_query(self, arg):
        """msg_query [ptn_id=NUM] [comp_id=NUM] [comp_str=TEXT]
                     [begin=TIMESTAMP] [end=TIMESTAMP]

        Query messages matching the given conditions.

        Conditions:
            ptn_id=NUM is the pattern ID from the store (e.g. 256).

            comp_id=NUM is the host ID from the store (e.g. 12345).

            comp_str=TEXT is the component text from the store (e.g.
            "nid00001").  This option overrides `comp_id` option.

            limit=NUM is the limitation to the number of messages. This apply
            only to the redirection mode.

            begin=TIMESTAMP constrains the result messages to have timestamp
            greater than or equals to the given TIMESTAMP.

            end=TIMESTAMP constrains the result messages to have timestamp less
            than or equals to the given TIMESTAMP.

            The TIMESTAMP format is "yyyy-mm-ddTHH:MM:SS[(+|-)HH:MM]".  It is
            the same timestamp format appeared in the results of `ptn_query` and
            `msg_query`, excluding the microsecond part. The microsecond can be
            put in, but will be ignored as currently our time index does not
            include the microsecond part. If the timezone (the trailing "-HH:MM"
            or "+HH:MM") is omitted, the system timezone is used.
        """

        global store
        itr = Bq.Bmsg_iter(store)
        (kwargs, args) = (self.kwargs, self.args)
        ts0 = kwargs["begin"]
        ts1 = kwargs["end"]
        ptn_id = kwargs["ptn_id"]
        comp_id = kwargs["comp_id"]
        comp_str = kwargs["comp_str"]
        if comp_str:
            tkn = store.tkn_by_name(comp_str)
            if not tkn:
                raise CmdException("Invalid comp_str: \"%s\"" % comp_str)
            comp_id = tkn.tkn_id()

        itr.set_filter( tv_begin = ts0,
                        tv_end = ts1,
                        ptn_id = ptn_id,
                        comp_id = comp_id )
        if self.cmdout.isatty():
            # use paging
            pager = PageDisplay(itr, MsgFormatter())
            pager.loop()
        else:
            n = 0
            limit = kwargs["limit"]
            fmt = MsgFormatter(color=False)
            for msg in itr:
                if limit and n == limit:
                    break
                print >>self.cmdout, fmt(msg)
                n += 1

    def parser_hist_query(self):
        return CmdArgumentParser(
            ("type", str, "TKN|PTN|COMP", 1, None),
            ("bin_width", int, "3600|60", 0, 3600),
            ("ptn_id", int, "INT", 0, 0),
            ("comp_id", int, "INT", 0, 0),
            ("comp_str", str, "STR", 0, None),
            ("tkn_id", int, "INT", 0, 0),
            ("tkn_str", str, "STR", 0, None),
            ("begin", util.Timestamp.fromStr, "TIMESTAMP", 0, None),
            ("end", util.Timestamp.fromStr, "TIMESTAMP", 0, None),
        )

    def do_hist_query(self, arg):
        """comp_hist_query type=TKN|PTN|COMP bin_width=60|3600|86400
                           [ptn_id=INT] [comp_id=INT] [comp_str=STR]
                           [tkn_id=INT] [tkn_str-STR] [begin=TIMESTAMP]
                           [end=TIMESTAMP] [>OUTPUT_FILE]

        Query historgram of given type restricted to the given conditions.

        The OUTPUT format is a list of histogram entries, one entry per line,
        described by following:
            - for TKN: BIN_WIDTH, UNIX_TIMESTAMP, TKN_ID, COUNT
            - for PTN: BIN_WIDTH, UNIX_TIMESTAMP, PTN_ID, COUNT
            - for COMP: BIN_WIDTH, UNIX_TIMESTAMP, COMP_ID, PTN_ID, COUNT.

        The results can be redirected into an OUTPUT_FILE by giving
        `>OUTPUT_FILE` at the end of the command.

        Conditions:
            bin_width=SECS is the bin-width (time) of the histogram. The
            possible values are 60, 3600, 86400. The default is 3600.

            ptn_id=INT is the pattern ID. This option is used only in type=PTN
            and type=COMP.

            comp_id=INT is the component ID. This option is used only in
            type=COMP. Alternatively, one may use `comp_str` parameter instead
            of comp_id.

            comp_str=STR is the component string. This option is used only in
            type=COMP. This option also overrides `comp_id` option.

            tkn_id=INT is the token ID. This option is used only in type=TKN.

            tkn_str=STR is the token string. This option is used only in
            type=TKN. This option also overrides `tkn_id` option.


            begin=TIMESTAMP constrains the results to have timestamp greater
            than or equals to the given TIMESTAMP.

            end=TIMESTAMP constrains the results to have timestamp less than or
            equals to the given TIMESTAMP.

            The TIMESTAMP format is "yyyy-mm-ddTHH:MM:SS[(+|-)HH:MM]".  It is
            the same timestamp format appeared in the results of `ptn_query` and
            `msg_query`, excluding the microsecond part. The microsecond can be
            put in, but will be ignored as currently our time index does not
            include the microsecond part. If the timezone (the trailing "-HH:MM"
            or "+HH:MM") is omitted, the system timezone is used.
        """
        global store
        (kwargs, args) = (self.kwargs, self.args)
        bin_width = kwargs["bin_width"]
        # preparing filter
        _fltr = {"bin_width": bin_width}
        ts0 = kwargs["begin"]
        if ts0:
            _fltr["tv_begin"] = ts0
        ts1 = kwargs["end"]
        if ts1:
            _fltr["tv_end"] = ts1
        for k in ["comp_id", "ptn_id", "tkn_id"]:
            x = kwargs[k]
            if x:
                _fltr[k] = x
        s = kwargs["comp_str"]
        if s:
            tkn = store.tkn_by_name(s)
            _fltr["comp_id"] = tkn.tkn_id()
        s = kwargs["tkn_str"]
        if s:
            tkn = store.tkn_by_name(s)
            _fltr["tkn_id"] = tkn.tkn_id()

        _type = kwargs["type"]
        if _type == "PTN":
            itr = Bq.Bptn_hist_iter(store)
        elif _type == "TKN":
            itr = Bq.Btkn_hist_iter(store)
        elif _type == "COMP":
            itr = Bq.Bcomp_hist_iter(store)
        else:
            raise CmdException("Unknown histogram type: %s" % _type)
        itr.set_filter(**_fltr)
        for hist in itr:
            print >>self.cmdout, str(hist)

    def do_EOF(self, arg):
        """Stop the command intepreter."""
        return True

    def do_quit(self, arg):
        """Stop the command intepreter."""
        return True

    def do_exit(self, arg):
        """Stop the command intepreter."""
        return True

    def emptyline(self):
        """Do nothing on empty line."""
        pass

    def precmd(self, line):
        """Apply our parser and store results in self.kwargs, self.args."""
        (self.kwargs, self.args) = ({}, [])
        self.cmdout = sys.stdout
        if not line:
            return line
        tmp = line.split(None, 1)
        cmd = tmp[0]
        arg = "" if len(tmp) == 1 else tmp[1]
        p = self.get_parser(cmd)
        if p:
            (self.kwargs, self.args) = p.parse(arg)
            # output redirection
            out_mask = [x.startswith(">") for x in self.args]
            s = sum(out_mask)
            if s > 1:
                # too many redirections
                raise CmdException("Too many redirections")
            if s:
                # has one file redirection
                try:
                    idx = out_mask.index(True)
                    out = self.args.pop(idx)
                    out_name = out.strip(">")
                    if not out_name:
                        out_name = self.args.pop(idx)
                    if out.startswith(">>"):
                        out = open(out_name, "a")
                    else:
                        out = open(out_name, "w")
                except Exception as e:
                    raise CmdException(str(e))
            else:
                out = sys.stdout
            self.cmdout = out
        return line # return same line for Cmd processing.

    def postcmd(self, stop, line):
        if self.cmdout != self.stdout:
            self.cmdout.close()
            self.cmdout = self.stdout # reset cmdout
        return stop

    def completedefault(self, text, line, begidx, endidx):
        cmd = line.split()[0]
        p = self.get_parser(cmd)
        if not p:
            return cmd.Cmd.completedefault(self, text, line, begidx, endidx)
        c = [x+"="+str(p.kwargs_hint[x]) \
                        for x in p.available_kwargs if x.startswith(text)]
        if len(c) == 1:
            x = c[0].split('=', 1)[0]
            c = [x+'=']
        return c

if __name__ == "__main__":
    # Setup basic logging if this is a main service.
    LOGFMT = "%(asctime)s %(name)s %(levelname)s: %(message)s"
    logging.basicConfig(format=LOGFMT)

    import argparse
    ap = argparse.ArgumentParser(description="Baler Service Client.")
    ap.add_argument("-P", "--plugin", action="store",
                    default="bstore_sos", type=str,
                    help="Store plugin."
            )
    ap.add_argument("-p", "--path", action="store",
                    default=None, type=str,
                    help="Store path."
            )
    ap.add_argument("-v", "--verbose", action="store",
                    default="INFO", type=str,
                    help="Verbosity level (DEBUG, INFO, WARN, ERROR, CRITICAL)"
            )
    args = ap.parse_args()
    logger.setLevel(logging.getLevelName(args.verbose.upper()))

    if args.path:
        open_store(args.path, args.plugin)

    svc_cmd = ServiceCmd()
    while True:
        try:
            svc_cmd.cmdloop()
        except CmdException as e:
            # in case of exception, print it and continue the loop
            print >>sys.stderr, "Error:", e
        else:
            # cmdloop exit cleanly, exit the program.
            break
    logger.debug("END OF PROGRAM.")
