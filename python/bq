#!/usr/bin/env python3
import datetime as dt
import argparse
from matplotlib.ticker import Formatter
from matplotlib import cm
import numpy as np
import textwrap
from baler import Bq
from baler import util
from baler import named2darray
import re
import os
import sys
import shlex

def xlate_bin_width(args):
    bw = args.bin_width
    if bw == 'd':
        return 86400
    elif bw == 'h':
        return 3600
    elif bw == 'm':
        return 60
    raise ValueError("{0} is an invalid bin width specification".format(bw))

def default_bin_width(dur):
    if dur  / 3600 > 60:
        bin_width = 86400
    elif dur / 60 > 60:
        bin_width = 3600
    else:
        bin_width = 60
    return bin_width

def tkn_id_from_args(args):
    if args.tkn_str:
        tkn = bs.tkn_by_name(args.tkn_str)
        if tkn:
            return tkn.tkn_id()
        else:
            raise NameError("There is no token with the name {0}".format(args.tkn_str))
    elif args.tkn_id is not None:
        if args.tkn_id != 0:
            tkn = bs.tkn_by_id(args.tkn_id)
            if tkn:
                return tkn.tkn_id()
            else:
                raise NameError("There is no token with the id {0}"
                                .format(args.tkn_id))
        else:
            return 0
    return None

def get_times_from_args(args):
    if args.begin:
        start = int(args.begin.strftime("%s"))
    else:
        start = 0

    if args.end:
        end = int(args.end.strftime("%s"))
    else:
        end = 0

    return (start, end)

def get_hist_args(it, key, args):
    key = int(key)
    start, end = get_times_from_args(args)
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        if start != 0 and end != 0:
            dur = end - start
        else:
            dur = it.duration()
            # in case one or the other of start/end were specified
            dur = dur - start - end
        bin_width = default_bin_width(dur)
    return (start, end, bin_width)

def bin_name(bin_width):
    if bin_width == 86400:
        return "1 day"
    elif bin_width == 3600:
        return "1 hour"
    else:
        return "1 minute"

class MyXFormatter(Formatter):
    def __init__(self, fmt='%m/%d %H:%M'):
        self.fmt = fmt

    def __call__(self, x, pos=0):
        x = int(x)
        d = dt.datetime.fromtimestamp(x)
        return d.strftime(self.fmt)

def autolabel(ax, rects, max_y, args):
    # attach some text labels
    if args.y_scale != 'log':
        offset = max_y * .025

    for rect in rects:
        height = rect.get_height()
        if args.y_scale == 'log':
            y = height * 1.1
        else:
            y = height + offset

        ax.text(rect.get_x() + rect.get_width()/2., y,
                '%d' % int(height),
                rotation='vertical',
                ha='center', va='bottom',
                size=args.label_size
            )

def plot_xy(x, y, title_str, bin_width, args):
    min_x = min(x) - (bin_width / 2)
    max_x = max(x) + bin_width
    max_y = max(y)
    if args.y_scale == 'log':
        max_y *= 10
    else:
        max_y += max_y * .2

    figure = plt.figure(figsize=(12,4))
    axis = figure.add_axes([0.075, 0.225, 0.875, 0.65], axisbg='w')
    axis.tick_params(labelsize=10, direction='out')
    axis.xaxis.set_major_formatter(MyXFormatter())
    figure.autofmt_xdate()

    rects = plt.bar(x, y, bin_width / 2, color='y')
    autolabel(axis, rects, max_y, args)

    axis.xaxis.set_major_formatter(MyXFormatter())

    s = dt.datetime.fromtimestamp(min_x)
    year_str = str(s.year)
    e = dt.datetime.fromtimestamp(max_x)
    if e.year != s.year:
        year_str += "-"+str(e.year)
    plt.xlabel('Date/Time ({0})'.format(year_str))
    plt.ylabel('Msg Count')
    plt.title(title_str)
    if args.y_scale == 'log':
        min_y = 1.0
    else:
        min_y = 0.
    plt.axis([min_x, max_x, min_y, max_y])
    plt.yscale(args.y_scale, nonposy='clip')
    plt.grid(True)
    plt.show()

def multi_bar(x, y, title_str, bin_width, args):
    """Create a Bar from multiple series

    Positional Arguments:
    --- Array of arrays of timestamps
    --- Array of arrays of bar values
    --- The width in seconds of each bin.
    --- The argument tuple passed in to main
    """
    if len(x) != len(y):
        raise ValueError("The x and y input vectors must be equal length.")
    # Determine min an max Time and Y value across the input vectors
    max_x = 0.0
    min_x = 99999999999
    for X in x:
        mx = min(X) - (bin_width / 2)
        if min_x > mx:
            min_x = mx
        mx = max(X) + bin_width
        if max_x < mx:
            max_x = mx
    max_y = 0.0
    for Y in y:
        my = max(Y)
        if max_y < my:
            max_y = my
    if args.y_scale == 'log':
        max_y *= 10
    else:
        max_y += max_y * .2

    height = 6.
    width = 16.
    bottom = 1.
    title_lines = len(title_str.split('\n'))
    top = title_lines * .25
    right = .5
    left = .75
    W = width - left - right
    H = height - top - bottom
    figure = plt.figure(figsize=(width, height))
    axis = figure.add_axes([left / width, bottom / height,
                            W / width, H / height], axisbg='w')
    axis.tick_params(labelsize=10, direction='out')
    figure.autofmt_xdate()

    ind = 0
    offset = 0
    width = bin_width / len(x)
    l = float(len(x))
    colors = cm.Set1(np.arange(l) / l)
    rects = []
    for X in x:
        Y = y[ind]
        ind += 1
        r = plt.bar(X+offset, Y, width, color=colors[ind % len(colors)])
        rects.append(r)
        offset += width
        autolabel(axis, r, max_y, args)

    axis.xaxis.set_major_formatter(MyXFormatter())
    lr = tuple(r[0] for r in rects)
    if args.ptn_ids:
        ptn_ids = str(args.ptn_ids).split(',')
    else:
        ptn_ids = [ str(args.ptn_id) ]
    ll = tuple(ptn for ptn in ptn_ids)
    axis.legend(lr, ll)
    s = dt.datetime.fromtimestamp(min_x)
    year_str = str(s.year)
    e = dt.datetime.fromtimestamp(max_x)
    if e.year != s.year:
        year_str += "-"+str(e.year)
    plt.xlabel('Date/Time ({0})'.format(year_str))
    plt.ylabel('Msg Count')
    plt.title(title_str) #, loc='left')
    if args.y_scale == 'log':
        min_y = 1.0
    else:
        min_y = 0.
    plt.axis([min_x, max_x, min_y, max_y])
    plt.yscale(args.y_scale, nonposy='clip')
    plt.grid(True)
    plt.show()

def plot_comp_hist(bs, args):
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        raise ValueError("The --comp_id or --comp_str arguments must be " \
                         "specified with --comp")
    tkn = bs.tkn_by_id(comp_id)

    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id

    it = Bq.Bcomp_hist_iter(bs)

    start, end, bin_width = get_hist_args(it, comp_id, args)

    it.set_filter(comp_id=comp_id, ptn_id=ptn_id, bin_width=bin_width,
                  tv_begin=(start, 0), tv_end=(end, 0))
    cnt, x, y = it.as_xy_arrays()
    if cnt == 0:
        print("No history information found for component {0} and pattern {1}". \
              format(comp_id, ptn_id))
        return

    ptn = bs.ptn_by_id(ptn_id)
    title_str = 'Pattern: {0}\nHost: {1}, Bin Width: {2}'. \
                format(str(ptn), tkn.tkn_str(), bin_name(bin_width))
    plot_xy(x, y, title_str, bin_width, args)

def plot_ptn_hist(bs, args):
    if not args.ptn_id and not args.ptn_ids:
        raise ValueError("The --ptn_id or --ptn_ids argument must be " \
                         "specified with --ptn --hist")
    if args.ptn_ids:
        ptn_ids = str(args.ptn_ids).split(',')
    else:
        ptn_ids = [ str(args.ptn_id) ]
    it = Bq.Bptn_hist_iter(bs)

    start, end, bin_width = get_hist_args(it, ptn_ids[0], args)

    x = []
    y = []
    cnt = 0.0
    title_str = ""
    for pi in ptn_ids:
        pi = int(pi)
        n, X, Y = it.as_xy_arrays(pi, bin_width,
                                  start_time=start, end_time=end)
        cnt += n
        if n != 0:
            x.append(X)
            y.append(Y)
            if pi == 1:             # ptn #1 is the wild-card
                ptn_str = "ALL"
            else:
                ptn = bs.ptn_by_id(pi)
                ptn_str = str(ptn)
            title_str += '{0}: {1}\n'.format(pi, textwrap.fill(ptn_str,120))

    if cnt == 0:
        print("No history information found for pattern {0}".format(ptn_id))
        return

    title_str += "Host: ALL, Bin Width: {0}\n".format(bin_width)

    multi_bar(x, y, title_str, bin_width, args)

def plot_tkn_hist(bs, args):
    tkn_id = tkn_id_from_args(args)
    if not tkn_id:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --tkn")
    it = Bq.Btkn_hist_iter(bs)
    start, end, bin_width = get_hist_args(it, tkn_id, args)
    it.set_filter(tkn_id=tkn_id, bin_width=bin_width,
                  tv_begin=(start, 0), tv_end=(end, 0))
    cnt, x, y = it.as_xy_arrays()
    if cnt == 0:
        print("No history information found for token {0}".format(tkn_id))
        return

    tkn = bs.tkn_by_id(tkn_id)
    title_str = 'Token: "{0}"\nHost: ALL, Bin Width: {1}'. \
                format(tkn.tkn_str(), bin_name(bin_width))
    plot_xy(x, y, title_str, bin_width, args)

def fmt_tstamp(ts, args):
    if args.unix_time:
        t = str(ts)
    else:
        t = str(dt.datetime.fromtimestamp(ts))
    if args.color:
       return BOLD + YELLOW + t + RESET + " "
    return t

def show_summary(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
    start, end = get_times_from_args(args)

    mi = Bq.Bmsg_iter(bs)
    pi = Bq.Bptn_iter(bs)
    pi.first()
    ptn_count = pi.count()
    print("Pattern Count        : {0}".format(ptn_count))
    msg_count = mi.count(1, start, end)
    print("Message Count        : {0}".format(msg_count))
    print("Messages per Pattern : {0}".format(msg_count / ptn_count))
    mi.set_filter(comp_id=comp_id, ptn_id=ptn_id,
                  tv_begin=(start, 0), tv_end=(end, 0))
    if mi.first():
        m = mi.obj()
        print("First Message        : {0}".format(fmt_tstamp(m.tv_sec(), args)))
        if args.verbose:
            print_msg(bs, m, args)
        mi.last()
        m = mi.obj()
        print("Last Message         : {0}".format(fmt_tstamp(m.tv_sec(), args)))
        if args.verbose:
            print_msg(bs, m, args)
    del mi
    del pi

def skip_token(tkn):
    return False
    if tkn.has_type(Bq.BTKN_TYPE_SEPARATOR):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_WHITESPACE):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_HEX_INT):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_DEC_INT):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_FLOAT):
        return True
    return False

def do_header(hdr_str, args):
    if args.header:
        print(hdr_str)

def do_footer(ftr_str, args):
    if args.header:
        print(ftr_str)

def show_ptn_tkns(bs, args):
    if not args.ptn_id:
        print("The --ptn_id argument is required with --ptn_tkn")
        return

    ptn = bs.ptn_by_id(args.ptn_id)
    if not ptn:
        print("A pattern with id {0} was not found".format(args.ptn_id))
        return

    tkn_count = ptn.tkn_count()
    pti = []
    col = []
    cnt = []
    for pos in range(0, tkn_count):
        it = Bq.Bptn_tkn_iter(bs, ptn_id=ptn.ptn_id(), tkn_pos=pos)
        it.first()
        pti.append(it)
        col.append(4)
        cnt.append(0)

    more = True
    # determine the column widths for each position
    while more:
        more = False
        for pos in range(0, tkn_count):
            tkn = None
            try:
                tkn = pti[pos].obj()
                if not pti[pos].next():
                    pti[pos] = None
            except:
                 pti[pos] = None
                 continue
            if tkn:
                if skip_token(tkn):
                    pti[pos] = None
                    continue
                more = True
                l = len(tkn.tkn_str())
                if l > col[pos]:
                    col[pos] = l
                cnt[pos] += 1

    # Print the header
    print("Ptn Id: {0} {1}".format(ptn.ptn_id(),
                                   str(ptn).center(sum(col)+len(col),
                                                   ' ')))
    for pos in range(0, tkn_count):
        print("{0} ".format(str(pos).center(col[pos], ' ')), end='')
    print("")
    sep = ""
    for pos in range(0, tkn_count):
        sep += "{0} ".format('-'.ljust(col[pos],'-'))
    print("{0}".format(sep))

    # reset the iterators
    for pos in range(0, tkn_count):
        it = Bq.Bptn_tkn_iter(bs, ptn_id=ptn.ptn_id(), tkn_pos=pos)
        it.first()
        pti[pos] = it

    more = True
    while more:
        more = False
        for pos in range(0, tkn_count):
            tkn = None
            try:
                if pti[pos]:
                    tkn = pti[pos].obj()
                    if not pti[pos].next():
                        pti[pos] = None
            except:
                pti[pos] = None
            if tkn:
                if skip_token(tkn):
                    pti[pos] = None
                    tkn_str = " "
                else:
                    tkn_str = tkn.tkn_str()
                    more = True
            else:
                tkn_str = " "
            print("{0:{width}s} ".format(tkn_str, width=col[pos]), end='')
        print("")
    print("{0}".format(sep))
    for pos in range(0, tkn_count):
        print("{0} ".format(str(cnt[pos]).center(col[pos], ' ')), end='')
    print("")

def plot_ptn_dist(bs, args):
    if not args.ptn_id:
        print("The --ptn_id argument is required with --dist")
        return

    ptn = bs.ptn_by_id(args.ptn_id)
    if not ptn:
        print("A pattern with id {0} was not found".format(args.ptn_id))
        return

    start, end = get_times_from_args(args)
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    # Gather the components
    comp_count = ptn.tkn_count()
    hit = Bq.Bptn_tkn_iter(bs, ptn_id=args.ptn_id)
    comps = []
    for tkn in hit:
        comps.append(tkn)

    # Compute the message count for each component
    counts = []
    ind = 0
    for c in comps:
        comp_id = comps[ind].tkn_id()
        hit = Bq.Bcomp_hist_iter(bs)
        hit.set_filter(comp_id=comp_id, ptn_id=ptn.ptn_id(),
                       bin_width=bin_width, tv_begin=(start, 0))
        counts.append(0)
        for h in hit:
            if end > 0 and h.time() > end:
                break
            counts[ind] += h.msg_count()

        print("comp_id {0} ptn_id {1} count {2}".format(comp_id, ptn.ptn_id(), counts[ind]))
        ind += 1
    labels = []
    for tkn in comps:
        labels.append(tkn.tkn_str())
    figure = plt.figure(figsize=(8,8))
    l = float(len(comps))
    cs=cm.Set1(np.arange(l) / l)
    title_str = '{0}[{1}]: {2}'.format(ptn.ptn_id(), bin_name(bin_width), str(ptn))
    plt.title(textwrap.fill(title_str, 60))
    plt.pie(counts, labels=labels, colors=cs, autopct='%1.1f%%', shadow=True)
    plt.text(0., 0., "{0} total messages".format(sum(counts)),
             horizontalalignment='center',
             verticalalignment='bottom')
    plt.show()

def print_msg(bs, m, args):
    comp_str = fmt_comp_str(bs, m.comp_id(), args)
    print("{0:12} {1:12} {2:20}".format(m.ptn_id(), comp_str,
                                        fmt_tstamp(m.tv_sec(), args)),
          end=' ')
    for tkn in m:
        tkn_str = fmt_tkn_str(tkn, args)
        print("{0}".format(tkn_str), end='')
    print("")

def show_msgs(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id

    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
    print("COMP_ID:", comp_id)

    start, end = get_times_from_args(args)

    do_header("{0:12} {1:12} {2:20} {3}". \
              format("Ptn Id", "Component", "Timestamp", "Message"), args)
    hf = "{0} {1} {2} {3}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'),
        '-'.ljust(20, '-'), '-'.ljust(32, '-'))
    do_header(hf, args)
    mi = Bq.Bmsg_iter(bs)
    mi.set_filter(comp_id=comp_id, ptn_id=ptn_id,
                  tv_begin=(start, 0), tv_end=(end, 0))
    msg_count = 0
    for m in mi:
        if end > 0 and m.tv_sec() > end:
            break
        msg_count += 1
        print_msg(bs, m, args)
        if args.limit and msg_count == args.limit:
            break
    do_footer(hf, args)
    do_footer("{0} Record(s)".format(msg_count), args)

NORM = ""
BLUE = "\033[34m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
RESET = "\033[0m"
BOLD =  "\033[1m"
UNDERLINE = "\033[4m"

type_colors = {
    Bq.BTKN_TYPE_TYPE : NORM,
    Bq.BTKN_TYPE_PRIORITY : NORM,
    Bq.BTKN_TYPE_VERSION : NORM,
    Bq.BTKN_TYPE_TIMESTAMP : BOLD + YELLOW,
    Bq.BTKN_TYPE_HOSTNAME : BOLD+GREEN,
    Bq.BTKN_TYPE_SERVICE : GREEN,
    Bq.BTKN_TYPE_PID : YELLOW,
    Bq.BTKN_TYPE_IP4_ADDR : NORM,
    Bq.BTKN_TYPE_IP6_ADDR : NORM,
    Bq.BTKN_TYPE_ETH_ADDR : NORM,
    Bq.BTKN_TYPE_HEX_INT : BOLD+BLUE,
    Bq.BTKN_TYPE_DEC_INT : BOLD+BLUE,
    Bq.BTKN_TYPE_FLOAT : BOLD+BLUE,
    Bq.BTKN_TYPE_PATH : BOLD+YELLOW,
    Bq.BTKN_TYPE_URL : BOLD+YELLOW,
    Bq.BTKN_TYPE_WORD : BOLD,
    Bq.BTKN_TYPE_SEPARATOR : NORM,
    Bq.BTKN_TYPE_WHITESPACE : NORM,
    Bq.BTKN_TYPE_TEXT : BOLD+RED,
}

tkn_type_ids = {
    "TYPE" : Bq.BTKN_TYPE_TYPE,
    "PRIO" : Bq.BTKN_TYPE_PRIORITY,
    "VERS" : Bq.BTKN_TYPE_VERSION,
    "TS" : Bq.BTKN_TYPE_TIMESTAMP,
    "HOST" : Bq.BTKN_TYPE_HOSTNAME,
    "SVC" : Bq.BTKN_TYPE_SERVICE,
    "PID" : Bq.BTKN_TYPE_PID,
    "IP4" : Bq.BTKN_TYPE_IP4_ADDR,
    "IP6" : Bq.BTKN_TYPE_IP6_ADDR,
    "MAC" : Bq.BTKN_TYPE_ETH_ADDR,
    "HEX" : Bq.BTKN_TYPE_HEX_INT,
    "DEC" : Bq.BTKN_TYPE_DEC_INT,
    "SEP" : Bq.BTKN_TYPE_SEPARATOR,
    "FLOAT" : Bq.BTKN_TYPE_FLOAT,
    "PATH" : Bq.BTKN_TYPE_PATH,
    "URL" : Bq.BTKN_TYPE_URL,
    "WORD" : Bq.BTKN_TYPE_WORD,
    "SPACE" : Bq.BTKN_TYPE_WHITESPACE,
    "TEXT" : Bq.BTKN_TYPE_TEXT
}

def show_tkns(bs, args):
    if args.tkn_type:
        type_str = args.tkn_type.upper()
        if type_str in tkn_type_ids:
            tkn_type = tkn_type_ids[type_str]
        else:
            tkn = bs.tkn_by_name("_{0}_".format(type_str))
            if not tkn:
                raise NameError("{0} is an invalid type name".format(type_str))
            tkn_type = tkn.tkn_id()
            del tkn
    else:
        tkn_type = None

    ti = Bq.Btkn_iter(bs)
    print("{0:12} {1:32} {2:12} {3}".format(
        "Tkn Id", "Tkn String", "Tkn Seen", "Types"))
    hf = "{0} {1} {2} {3}".format(
        '-'.ljust(12, '-'), '-'.ljust(32, '-'), '-'.ljust(12, '-'),
        '-'.ljust(32, '-'))
    print(hf)
    tkn_count = 0
    for tkn in ti:
        if tkn_type and not tkn.has_type(tkn_type):
            continue
        tkn_count += 1
        print("{0:12} {1:32} {2:12}". \
              format(tkn.tkn_id(), tkn.tkn_str(), tkn.tkn_count()), end=' ')
        for typ in tkn:
            print("{0}".format(bs.tkn_type_str(typ)), end=' ')
        print("")
    print(hf)
    print("{0} Record(s)".format(tkn_count))

def fmt_comp_str(bs, comp_id, args):
    try:
        if args.raw_id:
            return str(comp_id)
        tkn = bs.tkn_by_id(comp_id)
        if tkn:
            return tkn.tkn_str()
        return str(comp_id)
    except:
        return str(comp_id)

def fmt_tkn_str(tkn, args):
    tkn_str = ""
    if args and args.color:
        if tkn.tkn_id() in type_colors:
            tkn_str = type_colors[tkn.tkn_id()]
        elif tkn.first_type() in type_colors:
            tkn_str = type_colors[tkn.first_type()]
    if tkn.tkn_id() == Bq.BTKN_TYPE_WHITESPACE:
        tkn_str += " "
    else:
        tkn_str += tkn.ptn_tkn_str()
    if args and args.color:
        tkn_str += RESET
    return tkn_str

def show_matching_ptns(bs, args):
    tkn_id = tkn_id_from_args(args)
    if not tkn_id:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --match")
    match_tkn = bs.tkn_by_id(tkn_id)

    pi = Bq.Bptn_iter(bs)
    start, end = get_times_from_args(args)
    do_header("{0:12} {1:12} {2:20} {3:20} {4}".format(
        "Ptn Id", "Msg Count", "First Seen", "Last Seen", "Pattern"), args)
    hf = "{0} {1} {2} {3} {4}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'), '-'.ljust(20, '-'),
        '-'.ljust(20, '-'), '-'.ljust(32, '-'))
    do_header(hf, args)

    pi.set_filter(tv_begin=(start,0), tv_end=(end,0))
    ptn_count = 0
    matching_cols = {}
    for p in pi:
        if end > 0 and p.first_seen() > end:
            break

        # For each position in the pattern.
        #   If the type in that position doesn't match any of the token's types,
        #     skip this position
        #   otherwise
        #     search the pattern's ptn_tkn index for the token
        #     if tkn is found
        #         save the position
        #
        ptn_match = False
        pos = 0
        for tkn in p:
            if 0 == (tkn.type_mask() & match_tkn.type_mask()):
                pos += 1
                continue

            if tkn.tkn_id() == tkn_id:
                ptn_tkn = tkn
            else:
                ptn_tkn = p.find_tkn(pos, tkn_id)
            if ptn_tkn:
                if not ptn_match:
                    cols = []
                    cols.append(pos)
                    matching_cols[p.ptn_id()] = cols
                    ptn_match = True
                    pos += 1
                else:
                    matching_cols[p.ptn_id()].append(pos)
            pos += 1

        if not ptn_match:
            # This pattern does not contain the match token
            continue

        ptn_count += 1
        print("{0:12} {1:12} {2:20} {3:20}". \
              format(p.ptn_id(), p.msg_count(),
                     fmt_tstamp(p.first_seen(), args),
                     fmt_tstamp(p.last_seen(), args)), end=' ')
        pos = 0
        cpos = 13 + 13 + 21 + 21
        matches = []
        for tkn in p:
            if pos in matching_cols[p.ptn_id()]:
                tkn_str = UNDERLINE + fmt_tkn_str(tkn, args) + RESET
                matches.append(cpos+len(fmt_tkn_str(tkn, None))/2)
                cpos = 0
            else:
                tkn_str = fmt_tkn_str(tkn, args)
            print("{0}".format(tkn_str), end='')
            cpos += len(fmt_tkn_str(tkn, None))
            pos += 1
        print("")
        if args.loc:
            for col in matches:
                print("^".rjust(col, " "), end='')
            print("")

    do_footer(hf, args)
    do_footer("{0} Record(s)".format(ptn_count), args)

def print_ptn(p, args):
    print("{0:12} {1:12} {2:20} {3:20}". \
          format(p.ptn_id(), p.msg_count(),
                 fmt_tstamp(p.first_seen(), args),
                 fmt_tstamp(p.last_seen(), args)), end=' ')
    for tkn in p:
        tkn_str = fmt_tkn_str(tkn, args)
        print("{0}".format(tkn_str), end='')
    print("")

def show_ptns(bs, args):
    pi = Bq.Bptn_iter(bs)
    start, end = get_times_from_args(args)
    do_header("{0:12} {1:12} {2:20} {3:20} {4}".format(
        "Ptn Id", "Msg Count", "First Seen", "Last Seen", "Pattern"), args)
    hf = "{0} {1} {2} {3} {4}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'), '-'.ljust(20, '-'), '-'.ljust(20, '-'),
        '-'.ljust(32, '-'))
    do_header(hf, args)
    ptn_count = 0
    msg_count = 0
    if args.ptn_id:
        # single pattern
        p = bs.ptn_by_id(args.ptn_id)
        if p:
            ptn_count += 1
            print_ptn(p, args)
            msg_count += p.msg_count()
    else:
        pi.set_filter(tv_begin=(start, 0), tv_end=(end, 0))
        id_set = util.IDSet(args.ptn_ids) if args.ptn_ids else None
        ptns = [p for p in pi]
        if args.ptn_order:
            _cmp = util.get_ptn_cmp_by_name(args.ptn_order)
            if not _cmp:
                print("Unknown pattern order: %s" % args.ptn_order)
                return
            ptns.sort(_cmp)
        for p in ptns:
            if end > 0 and p.first_seen() > end:
                continue
            if id_set and p.ptn_id() not in id_set:
                continue
            ptn_count += 1
            print_ptn(p, args)
            msg_count += p.msg_count()
    do_footer(hf, args)
    do_footer("{0} Patterns(s) {1} Messages(s)".format(ptn_count, msg_count), args)

def show_ptn_hist(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    start, end = get_times_from_args(args)

    phi = Bq.Bptn_hist_iter(bs)
    phi.set_filter(ptn_id=ptn_id, bin_width=bin_width, tv_begin=(start,0))

    if not args.csv:
        hf = "{0:12} {1:20} {2:12} {3:12}".format("Ptn Id", "Timestamp",
                                                  "Bin Width", "Msg Count")
        sep = "{0} {1} {2} {3}".format('-'.ljust(12,'-'), '-'.ljust(20,'-'),
                                       '-'.ljust(12,'-'), '-'.ljust(12,'-'))
        do_header(hf, args)
        do_header(sep, args)
    else:
        hf = "# {0},{1},{2},{3}".format("Ptn Id", "Timestamp",
                                        "Bin Width", "Msg Count")
        do_header(hf, args)

    msg_count = 0
    rec_count = 0
    phi.first()
    for h in phi:
        if end > 0 and h.time() > end:
            break
        if not args.csv:
            print("{0:12} {1:20} {2:12} {3:12}" \
                  .format(h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        else:
            print("{0},{1},{2},{3}" \
                  .format(h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        rec_count += 1
        msg_count += h.msg_count()
    if not args.csv:
        do_footer(sep, args)
        do_footer("{0:46} {1:12}".format("{0} Record(s)".format(rec_count),
                                         msg_count), args)

def show_tkn_hist(bs, args):
    tkn_id = tkn_id_from_args(args)
    if tkn_id is None:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --tkn")

    ti = Bq.Btkn_hist_iter(bs)
    start, end, bin_width = get_hist_args(ti, tkn_id, args)
    ti.set_filter(tkn_id=tkn_id, bin_width=bin_width, tv_begin=(start,0))
    if not args.csv:
        do_header("{0:12} {1:20} {2:20} {3:12} {4:12}"
                  .format("Tkn Id", "Tkn Text", "Timestamp",
                          "Bin Width", "Msg Count"), args)
        hf = "{0} {1} {2} {3} {4}".format('-'.ljust(12,'-'),
                                          '-'.ljust(20,'-'),
                                          '-'.ljust(20,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(12,'-'))
        do_header(hf, args)
    else:
        do_header("# {0},{1},{2},{3},{4}".format("Tkn Id", "Tkn Text", "Timestamp",
                                             "Bin Width", "Msg Count"), args)
    msg_count = 0
    rec_count = 0
    for h in ti:
        tkn = bs.tkn_by_id(h.tkn_id())
        if end > 0 and h.time() > end:
            break
        if not args.csv:
            do_header("{0:12} {1:20} {2:20} {3:12} {4:12}" \
                  .format(h.tkn_id(), tkn.tkn_str(),
                          fmt_tstamp(h.time(), args),
                          h.bin_width(), h.tkn_count()), args)
        else:
            print("{0},{1},{2},{3},{4}" \
                  .format(h.tkn_id(), tkn.tkn_str(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.tkn_count()))
        rec_count += 1
        msg_count += h.tkn_count()
    if not args.csv:
        do_footer(hf, args)
        do_footer("{0:46} {1:12}". \
                  format("{0} Record(s)". format(rec_count), msg_count), args)

def show_comp_hist(bs, args):
    start, end = get_times_from_args(args)
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
        # raise ValueError("The --comp_id or --comp_str arguments must be " \
        #                 "specified with --comp")
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    chi = Bq.Bcomp_hist_iter(bs)
    chi.set_filter(comp_id=comp_id, ptn_id=ptn_id, bin_width=bin_width,
                   tv_begin=(start, 0))
    if not args.csv:
        do_header("{0:12} {1:12} {2:20} {3:12} {4:12}". \
                  format("Component", "Ptn Id", "Timestamp",
                         "Bin Width", "Msg Count"), args)
        hf = "{0} {1} {2} {3} {4}".format('-'.ljust(12,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(20,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(12,'-'))
        do_header(hf, args)
    else:
        do_header("# {0},{1},{2},{3},{4}". \
                  format("Component", "Ptn Id", "Timestamp",
                         "Bin Width", "Msg Count"), args)
    msg_count = 0
    rec_count = 0
    for h in chi:
        if end > 0 and h.time() > end:
            break
        comp_str = fmt_comp_str(bs, h.comp_id(), args)
        if not args.csv:
            print("{0:12} {1:12} {2:20} {3:12} {4:12}" \
                  .format(comp_str, h.ptn_id(),
                          fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        else:
            print("{0},{1},{2},{3},{4}" \
                  .format(h.comp_id(), h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        rec_count += 1
        msg_count += h.msg_count()
    if not args.csv:
        do_footer(hf, args)
        do_footer("{0:59} {1:12}".format("{0} Record(s)". \
                                         format(rec_count), msg_count), args)

def valid_date(date_str):
    try:
        return dt.datetime.strptime(date_str, "%Y/%m/%d %H:%M")
    except:
        msg = "{0} is not a valid date".format(date_str)
        raise argparse.ArgumentTypeError(msg)

DEFAULT_NAMED_QUERY_FILE_PATH = "/etc/bq.list"
NAMED_QUERY_TABLE = dict()
def load_named_query_table(path):
    line_no = 0
    cmt = re.compile("^\W*#")
    fmt = re.compile("^\W*(\w+)\W*=(.*)") # name = options
    f = open(path, "rt")
    line = f.readline()
    while line:
        line_no += 1
        line = line.rstrip() # strip the appending white spaces
        if not line:
            # empty line
            line = f.readline()
            continue
        if cmt.match(line):
            # This is a comment
            line = f.readline()
            continue
        if line.endswith("\\"):
            # get next line
            line = line.rstrip("\\")
            line += " " + f.readline()
            continue
        m = fmt.match(line)
        if not m:
            raise Exception("Named query parse error: line number: %d" % line_no)
        (name, options) = m.groups()
        if name in NAMED_QUERY_TABLE:
            raise Exception("Named query error: name '%s' existed, line number: %d" % (name, line_no))
        NAMED_QUERY_TABLE[name] = options
        line = f.readline()

def generate_named_2d_array(bs, args):
    if os.path.exists(args.named_2d_array):
        raise Exception("named-2d-array file existed")
    n2da = named2darray.Named2DArray(args.named_2d_array, "w")
    if args.name:
        n2da.set_name(args.name)
    else:
        n2da.set_name(os.path.basename(args.named_2d_array))
    start, end = get_times_from_args(args)
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours
    n2da.set_time_bin_width(bin_width)

    chi = Bq.Bcomp_hist_iter(bs)
    chi.set_filter(comp_id=comp_id, ptn_id=ptn_id, bin_width=bin_width,
                   tv_begin=(start, 0))
    ts = 0
    comp_id = 0
    count = 0
    for h in chi:
        _ts = h.time()
        _comp_id = h.comp_id()
        _count = h.msg_count()
        # data from the `chi` iterator is ordered by time-comp
        if end > 0 and _ts > end:
            break
        if _ts != ts or _comp_id != comp_id:
            if count:
                # flush the collective count across ptn_ids
                n2da.append(ts, comp_id, count)
            # update new collective count
            ts = _ts
            comp_id = _comp_id
            count = _count
        else:
            count += _count
    # flush the last count
    n2da.append(ts, comp_id, count)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Query Baler data")
    parser.add_argument("-p", "--path", required=True,
                        help="The path to the Baler store")
    parser.add_argument("-q", "--named-query", type=str, required=False,
                        metavar='NAME', default=None,
                        help="Use the named query from `named-query-file`.")
    parser.add_argument("-Q", "--named-query-file", type=str, required=False,
                        default=DEFAULT_NAMED_QUERY_FILE_PATH,
                        metavar='PATH',
                        help="The path to the named query file. "
                        "The format of the file is simply `name = options` "
                        "for each line. If the line is too long `\` can be "
                        "used at the end of the line to concatenate the next "
                        "line. The leading `#` marks the line as a comment."
                        )
    parser.add_argument("-m", "--msg", action="store_true",
                        help="Query messages")
    parser.add_argument("--limit", type=int,
                        help="Limit the number of messages to print")
    parser.add_argument("--begin", type=valid_date,
                        help="Specify the start time/date for the query. " \
                        "Format is YYYY/MM/DD HH:MM")
    parser.add_argument("--end", type=valid_date,
                        help="Specify the start time/date for the query. " \
                        "Format is YYYY/MM/DD HH:MM")
    parser.add_argument("--ptn", action="store_true",
                        help="Query patterns.")
    parser.add_argument("--ptn-order", type=str, help="Pattern order.")
    parser.add_argument("--comp", action="store_true",
                        help="Query component histories")
    parser.add_argument("--named-2d-array", type=str,
                        help="Generate a named-2d-array file from the " \
                        "component histories", default=None)
    parser.add_argument("--name", type=str, help="Name of the named-2d-array",
                        default=None)
    parser.add_argument("--summary", action="store_true",
                        help="Show a summary of the database")
    parser.add_argument("--verbose", action="store_true",
                        help="Show more detailed summary information")
    parser.add_argument("--tkn", action="store_true",
                        help="Query tokens")
    parser.add_argument("--tkn_type",
                        help="Specifies the type of a token")
    parser.add_argument("--tkn_id", type=int,
                        help="Specifies the integer id for a token")
    parser.add_argument("--tkn_str",
                        help="Specifies the string value of a token.")
    parser.add_argument("--match", action="store_true",
                        help="Show the patterns that contain a token")
    parser.add_argument("--hist", action="store_true",
                        help="Query the occurance histogram for --tkn, --ptn, and --comp")
    parser.add_argument("--dist", action="store_true",
                        help="Query the disrtribution --tkn, --ptn, and --comp")
    parser.add_argument("--ptn_tkn", action="store_true",
                        help="Query the tokens that appear in a pattern")
    parser.add_argument("--ptn_id", type=int,
                        help="The pattern id.")
    parser.add_argument("--ptn_ids",
                        help="A comma separated list of pattern ids.")
    parser.add_argument("--comp_id", dest="tkn_id", type=int,
                        help="Specifies a component id")
    parser.add_argument("--comp_str", dest="tkn_str",
                        help="Specifies the component name")
    parser.add_argument("--bin_width", choices=['d', 'h', 'm'],
                        help="Specifies the histogram bin width")
    parser.add_argument("--color", action="store_true",
                        help="Set to color code tokens.")
    parser.add_argument("--csv", action="store_true",
                        help="Format the output as a comma separated text")
    parser.add_argument("--unix_time", action="store_true",
                        help="Format time as a Unix timestamp")
    parser.add_argument("--raw_id", action="store_true",
                        help="Show token id for component name instead of text")
    parser.add_argument("--plot", action="store_true",
                        help="Plot the data instead of displaying it as text")
    parser.add_argument("--label_size", type=int, default=9,
                        help="Specify the bar label font size")
    parser.add_argument("--y_scale", default='linear',
                        help="Specify the y-scale as 'log' or 'linear'")
    header = parser.add_mutually_exclusive_group(required=False)
    header.add_argument("--header", dest="header", action="store_true",
                        help="Enable table headers")
    header.add_argument("--no-header", dest="header", action="store_false",
                        help="Disable table headers")
    locator = parser.add_mutually_exclusive_group(required=False)
    locator.add_argument("--loc", dest="loc", action="store_true",
                        help="Put a ^ character beneath the matching " \
                         "token in a pattern")
    locator.add_argument("--no-loc", dest="loc", action="store_false",
                        help="Do not put a ^ character beneath the matching " \
                         "token in a pattern")
    parser.set_defaults(loc=True)
    parser.set_defaults(header=True)

    args = parser.parse_args()

    # named query file handling
    if args.named_query_file != DEFAULT_NAMED_QUERY_FILE_PATH or \
                            os.path.isfile(args.named_query_file):
        # If named_query_file is the default, and the default file does not
        # exist, don't load it.
        load_named_query_table(args.named_query_file)

    # named query handling
    if args.named_query:
        try:
            nq = NAMED_QUERY_TABLE[args.named_query]
        except:
            print("Named query '%s' not found!" % args.named_query)
            sys.exit(-1)
        # append arguments and reparse
        new_argv = sys.argv[1:] + shlex.split(nq)
        args = parser.parse_args(new_argv)

    bs = Bq.Bstore()
    try:
        bs.open(args.path)
    except Exception as e:
        print(e)

    if args.summary:
        try:
            show_summary(bs, args)
        except Exception as e:
            print(e)

    if args.plot:
        import matplotlib.pyplot as plt
        import matplotlib.mlab as mlab
        import matplotlib.dates as mdates

    if args.tkn:
        try:
            if args.hist:
                if args.plot:
                    plot_tkn_hist(bs, args)
                else:
                    show_tkn_hist(bs, args)
            else:
                show_tkns(bs, args)
        except Exception as e:
            print(e)

    if args.match and not args.ptn:
        print("The --match option is ignored without the --ptn option")

    if args.ptn:
        try:
            if args.hist:
                if args.plot:
                    plot_ptn_hist(bs, args)
                else:
                    show_ptn_hist(bs, args)
            elif args.dist:
                plot_ptn_dist(bs, args)
            elif args.match:
                show_matching_ptns(bs, args)
            else:
                show_ptns(bs, args)
        except Exception as e:
            print(e)

    if args.comp:
        try:
            if args.named_2d_array:
                generate_named_2d_array(bs, args)
            elif not args.plot:
                show_comp_hist(bs, args)
            else:
                plot_comp_hist(bs, args)
        except Exception as e:
            print(e)

    if args.ptn_tkn:
        try:
            show_ptn_tkns(bs, args)
        except Exception as e:
            print(e)

    if args.msg:
        try:
            show_msgs(bs, args)
        except Exception as e:
            print(e)
