#!/usr/bin/env python
from __future__ import print_function
import datetime as dt
import argparse
from matplotlib.ticker import Formatter
from matplotlib import cm
import numpy as np
import textwrap
from baler import Bq
from baler import util

def xlate_bin_width(args):
    bw = args.bin_width
    if bw == 'd':
        return 86400
    elif bw == 'h':
        return 3600
    elif bw == 'm':
        return 60
    raise ValueError("{0} is an invalid bin width specification".format(bw))

def default_bin_width(dur):
    if dur  / 3600 > 60:
        bin_width = 86400
    elif dur / 60 > 60:
        bin_width = 3600
    else:
        bin_width = 60
    return bin_width

def tkn_id_from_args(args):
    if args.tkn_str:
        tkn = bs.tkn_by_name(args.tkn_str)
        if tkn:
            return tkn.tkn_id()
        else:
            raise NameError("There is no token with the name {0}".format(args.tkn_str))
    elif args.tkn_id is not None:
        if args.tkn_id != 0:
            tkn = bs.tkn_by_id(args.tkn_id)
            if tkn:
                return tkn.tkn_id()
            else:
                raise NameError("There is no token with the id {0}"
                                .format(args.tkn_id))
        else:
            return 0
    return None

def get_times_from_args(args):
    if args.begin:
        start = int(args.begin.strftime("%s"))
    else:
        start = 0

    if args.end:
        end = int(args.end.strftime("%s"))
    else:
        end = 0

    return (start, end)

def get_hist_args(it, key, args):
    key = int(key)
    start, end = get_times_from_args(args)
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        if start != 0 and end != 0:
            dur = end - start
        else:
            dur = it.duration()
            # in case one or the other of start/end were specified
            dur = dur - start - end
        bin_width = default_bin_width(dur)
    return (start, end, bin_width)

def bin_name(bin_width):
    if bin_width == 86400:
        return "1 day"
    elif bin_width == 3600:
        return "1 hour"
    else:
        return "1 minute"

class MyXFormatter(Formatter):
    def __init__(self, fmt='%m/%d %H:%M'):
        self.fmt = fmt

    def __call__(self, x, pos=0):
        x = int(x)
        d = dt.datetime.fromtimestamp(x)
        return d.strftime(self.fmt)

def autolabel(ax, rects, max_y, args):
    # attach some text labels
    if args.y_scale != 'log':
        offset = max_y * .025

    for rect in rects:
        height = rect.get_height()
        if args.y_scale == 'log':
            y = height * 1.1
        else:
            y = height + offset

        ax.text(rect.get_x() + rect.get_width()/2., y,
                '%d' % int(height),
                rotation='vertical',
                ha='center', va='bottom',
                size=args.label_size
            )

def plot_xy(x, y, title_str, bin_width, args):
    min_x = min(x) - (bin_width / 2)
    max_x = max(x) + bin_width
    max_y = max(y)
    if args.y_scale == 'log':
        max_y *= 10
    else:
        max_y += max_y * .2

    figure = plt.figure(figsize=(12,4))
    axis = figure.add_axes([0.075, 0.225, 0.875, 0.65], axisbg='w')
    axis.tick_params(labelsize=10, direction='out')
    axis.xaxis.set_major_formatter(MyXFormatter())
    figure.autofmt_xdate()

    rects = plt.bar(x, y, bin_width / 2, color='y')
    autolabel(axis, rects, max_y, args)

    axis.xaxis.set_major_formatter(MyXFormatter())

    s = dt.datetime.fromtimestamp(min_x)
    year_str = str(s.year)
    e = dt.datetime.fromtimestamp(max_x)
    if e.year != s.year:
        year_str += "-"+str(e.year)
    plt.xlabel('Date/Time ({0})'.format(year_str))
    plt.ylabel('Msg Count')
    plt.title(title_str)
    if args.y_scale == 'log':
        min_y = 1.0
    else:
        min_y = 0.
    plt.axis([min_x, max_x, min_y, max_y])
    plt.yscale(args.y_scale, nonposy='clip')
    plt.grid(True)
    plt.show()

def multi_bar(x, y, title_str, bin_width, args):
    """Create a Bar from multiple series

    Positional Arguments:
    --- Array of arrays of timestamps
    --- Array of arrays of bar values
    --- The width in seconds of each bin.
    --- The argument tuple passed in to main
    """
    if len(x) != len(y):
        raise ValueError("The x and y input vectors must be equal length.")
    # Determine min an max Time and Y value across the input vectors
    max_x = 0.0
    min_x = 99999999999
    for X in x:
        mx = min(X) - (bin_width / 2)
        if min_x > mx:
            min_x = mx
        mx = max(X) + bin_width
        if max_x < mx:
            max_x = mx
    max_y = 0.0
    for Y in y:
        my = max(Y)
        if max_y < my:
            max_y = my
    if args.y_scale == 'log':
        max_y *= 10
    else:
        max_y += max_y * .2

    height = 6.
    width = 16.
    bottom = 1.
    title_lines = len(title_str.split('\n'))
    top = title_lines * .25
    right = .5
    left = .75
    W = width - left - right
    H = height - top - bottom
    figure = plt.figure(figsize=(width, height))
    axis = figure.add_axes([left / width, bottom / height,
                            W / width, H / height], axisbg='w')
    axis.tick_params(labelsize=10, direction='out')
    figure.autofmt_xdate()

    ind = 0
    offset = 0
    width = bin_width / len(x)
    l = float(len(x))
    colors = cm.Set1(np.arange(l) / l)
    rects = []
    for X in x:
        Y = y[ind]
        ind += 1
        r = plt.bar(X+offset, Y, width, color=colors[ind % len(colors)])
        rects.append(r)
        offset += width
        autolabel(axis, r, max_y, args)

    axis.xaxis.set_major_formatter(MyXFormatter())
    lr = tuple(r[0] for r in rects)
    if args.ptn_ids:
        ptn_ids = str(args.ptn_ids).split(',')
    else:
        ptn_ids = [ str(args.ptn_id) ]
    ll = tuple(ptn for ptn in ptn_ids)
    axis.legend(lr, ll)
    s = dt.datetime.fromtimestamp(min_x)
    year_str = str(s.year)
    e = dt.datetime.fromtimestamp(max_x)
    if e.year != s.year:
        year_str += "-"+str(e.year)
    plt.xlabel('Date/Time ({0})'.format(year_str))
    plt.ylabel('Msg Count')
    plt.title(title_str) #, loc='left')
    if args.y_scale == 'log':
        min_y = 1.0
    else:
        min_y = 0.
    plt.axis([min_x, max_x, min_y, max_y])
    plt.yscale(args.y_scale, nonposy='clip')
    plt.grid(True)
    plt.show()

def plot_comp_hist(bs, args):
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        raise ValueError("The --comp_id or --comp_str arguments must be " \
                         "specified with --comp")
    tkn = bs.tkn_by_id(comp_id)

    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id

    it = Bq.Bcomp_hist_iter(bs)

    start, end, bin_width = get_hist_args(it, comp_id, args)

    it.set_filter(comp_id=comp_id, ptn_id=ptn_id, bin_width=bin_width,
                  tv_begin=(start, 0), tv_end=(end, 0))
    cnt, x, y = it.as_xy_arrays()
    if cnt == 0:
        print("No history information found for component {0} and pattern {1}". \
              format(comp_id, ptn_id))
        return

    ptn = bs.ptn_by_id(ptn_id)
    title_str = 'Pattern: {0}\nHost: {1}, Bin Width: {2}'. \
                format(str(ptn), tkn.tkn_str(), bin_name(bin_width))
    plot_xy(x, y, title_str, bin_width, args)

def plot_ptn_hist(bs, args):
    if not args.ptn_id and not args.ptn_ids:
        raise ValueError("The --ptn_id or --ptn_ids argument must be " \
                         "specified with --ptn --hist")
    if args.ptn_ids:
        ptn_ids = str(args.ptn_ids).split(',')
    else:
        ptn_ids = [ str(args.ptn_id) ]
    it = Bq.Bptn_hist_iter(bs)

    start, end, bin_width = get_hist_args(it, ptn_ids[0], args)

    x = []
    y = []
    cnt = 0.0
    title_str = ""
    for pi in ptn_ids:
        pi = int(pi)
        n, X, Y = it.as_xy_arrays(pi, bin_width,
                                  start_time=start, end_time=end)
        cnt += n
        if n != 0:
            x.append(X)
            y.append(Y)
            if pi == 1:             # ptn #1 is the wild-card
                ptn_str = "ALL"
            else:
                ptn = bs.ptn_by_id(pi)
                ptn_str = str(ptn)
            title_str += '{0}: {1}\n'.format(pi, textwrap.fill(ptn_str,120))

    if cnt == 0:
        print("No history information found for pattern {0}".format(ptn_id))
        return

    title_str += "Host: ALL, Bin Width: {0}\n".format(bin_width)

    multi_bar(x, y, title_str, bin_width, args)

def plot_tkn_hist(bs, args):
    tkn_id = tkn_id_from_args(args)
    if not tkn_id:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --tkn")
    it = Bq.Btkn_hist_iter(bs)
    start, end, bin_width = get_hist_args(it, tkn_id, args)
    it.set_filter(tkn_id=tkn_id, bin_width=bin_width,
                  tv_begin=(start, 0), tv_end=(end, 0))
    cnt, x, y = it.as_xy_arrays()
    if cnt == 0:
        print("No history information found for token {0}".format(tkn_id))
        return

    tkn = bs.tkn_by_id(tkn_id)
    title_str = 'Token: "{0}"\nHost: ALL, Bin Width: {1}'. \
                format(tkn.tkn_str(), bin_name(bin_width))
    plot_xy(x, y, title_str, bin_width, args)

def fmt_tstamp(ts, args):
    if args.unix_time:
        t = str(ts)
    else:
        t = str(dt.datetime.fromtimestamp(ts))
    if args.color:
       return BOLD + YELLOW + t + RESET + " "
    return t

def show_summary(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
    start, end = get_times_from_args(args)

    mi = Bq.Bmsg_iter(bs)
    pi = Bq.Bptn_iter(bs)
    ptn_count = pi.count(0)
    print("Pattern Count        : {0}".format(ptn_count))
    msg_count = mi.count(1)
    print("Message Count        : {0}".format(msg_count))
    print("Messages per Pattern : 1/{0}".format(msg_count / ptn_count))
    if mi.start(comp_id, ptn_id, start):
        m = mi.next()
        print("First Message        : {0}".format(fmt_tstamp(m.tv_sec(), args)))
        if args.verbose:
            print_msg(bs, m, args)
        mi.end()
        m = mi.next()
        print("Last Message         : {0}".format(fmt_tstamp(m.tv_sec(), args)))
        if args.verbose:
            print_msg(bs, m, args)
    del mi
    del pi

def skip_token(tkn):
    return False
    if tkn.has_type(Bq.BTKN_TYPE_SEPARATOR):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_WHITESPACE):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_HEX_INT):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_DEC_INT):
        return True
    elif tkn.has_type(Bq.BTKN_TYPE_FLOAT):
        return True
    return False

def do_header(hdr_str, args):
    if args.header:
        print(hdr_str)

def do_footer(ftr_str, args):
    if args.header:
        print(ftr_str)

def show_ptn_tkns(bs, args):
    if not args.ptn_id:
        print("The --ptn_id argument is required with --ptn_tkn")
        return

    ptn = bs.ptn_by_id(args.ptn_id)
    if not ptn:
        print("A pattern with id {0} was not found".format(args.ptn_id))
        return

    tkn_count = ptn.tkn_count()
    pti = []
    col = []
    cnt = []
    for pos in range(0, tkn_count):
        it = Bq.Bptn_tkn_iter(bs, ptn_id=ptn.ptn_id(), tkn_pos=pos)
        it.first()
        pti.append(it)
        col.append(4)
        cnt.append(0)

    more = True
    # determine the column widths for each position
    while more:
        more = False
        for pos in range(0, tkn_count):
            tkn = None
            try:
                tkn = pti[pos].obj()
                if not pti[pos].next():
                    pti[pos] = None
            except:
                 pti[pos] = None
                 continue
            if tkn:
                if skip_token(tkn):
                    pti[pos] = None
                    continue
                more = True
                l = len(tkn.tkn_str())
                if l > col[pos]:
                    col[pos] = l
                cnt[pos] += 1

    # Print the header
    print("Ptn Id: {0} {1}".format(ptn.ptn_id(),
                                   str(ptn).center(sum(col)+len(col),
                                                   ' ')))
    for pos in range(0, tkn_count):
        print("{0} ".format(str(pos).center(col[pos], ' ')), end='')
    print("")
    sep = ""
    for pos in range(0, tkn_count):
        sep += "{0} ".format('-'.ljust(col[pos],'-'))
    print("{0}".format(sep))

    # reset the iterators
    for pos in range(0, tkn_count):
        it = Bq.Bptn_tkn_iter(bs, ptn_id=ptn.ptn_id(), tkn_pos=pos)
        it.first()
        pti[pos] = it

    more = True
    while more:
        more = False
        for pos in range(0, tkn_count):
            tkn = None
            try:
                if pti[pos]:
                    tkn = pti[pos].obj()
                    if not pti[pos].next():
                        pti[pos] = None
            except:
                pti[pos] = None
            if tkn:
                if skip_token(tkn):
                    pti[pos] = None
                    tkn_str = " "
                else:
                    tkn_str = tkn.tkn_str()
                    more = True
            else:
                tkn_str = " "
            print("{0:{width}s} ".format(tkn_str, width=col[pos]), end='')
        print("")
    print("{0}".format(sep))
    for pos in range(0, tkn_count):
        print("{0} ".format(str(cnt[pos]).center(col[pos], ' ')), end='')
    print("")

def plot_ptn_dist(bs, args):
    if not args.ptn_id:
        print("The --ptn_id argument is required with --dist")
        return

    ptn = bs.ptn_by_id(args.ptn_id)
    if not ptn:
        print("A pattern with id {0} was not found".format(args.ptn_id))
        return

    start, end = get_times_from_args(args)
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    # Gather the components
    comp_count = ptn.tkn_count()
    hit = Bq.Bptn_tkn_iter(bs)
    hit.find(ptn.ptn_id(), 0)
    comps = []
    for tkn in hit:
        comps.append(tkn)

    # Compute the message count for each component
    counts = []
    ind = 0
    for c in comps:
        comp_id = comps[ind].tkn_id()
        hit = Bq.Bcomp_hist_iter(bs)
        hit.set_filter(comp_id=comp_id, ptn_id=ptn.ptn_id(),
                       bin_width=bin_width, tv_begin=(start, 0))
        counts.append(0)
        for h in hit:
            if end > 0 and h.time() > end:
                break
            counts[ind] += h.msg_count()

        print("comp_id {0} ptn_id {1} count {2}".format(comp_id, ptn.ptn_id(), counts[ind]))
        ind += 1
    labels = []
    for tkn in comps:
        labels.append(tkn.tkn_str())
    figure = plt.figure(figsize=(8,8))
    l = float(len(comps))
    cs=cm.Set1(np.arange(l) / l)
    title_str = '{0}[{1}]: {2}'.format(ptn.ptn_id(), bin_name(bin_width), str(ptn))
    plt.title(textwrap.fill(title_str, 60))
    plt.pie(counts, labels=labels, colors=cs, autopct='%1.1f%%', shadow=True)
    plt.text(0., 0., "{0} total messages".format(sum(counts)),
             horizontalalignment='center',
             verticalalignment='bottom')
    plt.show()

def print_msg(bs, m, args):
    comp_str = fmt_comp_str(bs, m.comp_id(), args)
    print("{0:12} {1:12} {2:20}".format(m.ptn_id(), comp_str,
                                        fmt_tstamp(m.tv_sec(), args)),
          end=' ')
    for tkn in m:
        tkn_str = fmt_tkn_str(tkn, args)
        print("{0}".format(tkn_str), end='')
    print("")

def show_msgs(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id

    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
    print("COMP_ID:", comp_id)

    start, end = get_times_from_args(args)

    do_header("{0:12} {1:12} {2:20} {3}". \
              format("Ptn Id", "Component", "Timestamp", "Message"), args)
    hf = "{0} {1} {2} {3}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'),
        '-'.ljust(20, '-'), '-'.ljust(32, '-'))
    do_header(hf, args)
    mi = Bq.Bmsg_iter(bs)
    mi.set_filter(comp_id=comp_id, ptn_id=ptn_id,
                  tv_begin=(start, 0), tv_end=(end, 0))
    msg_count = 0
    for m in mi:
        if end > 0 and m.tv_sec() > end:
            break
        msg_count += 1
        print_msg(bs, m, args)
    do_footer(hf, args)
    do_footer("{0} Record(s)".format(msg_count), args)

NORM = ""
BLUE = "\033[34m"
RED = "\033[31m"
GREEN = "\033[32m"
YELLOW = "\033[33m"
RESET = "\033[0m"
BOLD =  "\033[1m"
UNDERLINE = "\033[4m"

type_colors = {
    Bq.BTKN_TYPE_TYPE : NORM,
    Bq.BTKN_TYPE_PRIORITY : NORM,
    Bq.BTKN_TYPE_VERSION : NORM,
    Bq.BTKN_TYPE_TIMESTAMP : BOLD + YELLOW,
    Bq.BTKN_TYPE_HOSTNAME : BOLD+GREEN,
    Bq.BTKN_TYPE_SERVICE : GREEN,
    Bq.BTKN_TYPE_PID : YELLOW,
    Bq.BTKN_TYPE_IP4_ADDR : NORM,
    Bq.BTKN_TYPE_IP6_ADDR : NORM,
    Bq.BTKN_TYPE_ETH_ADDR : NORM,
    Bq.BTKN_TYPE_HEX_INT : BOLD+BLUE,
    Bq.BTKN_TYPE_DEC_INT : BOLD+BLUE,
    Bq.BTKN_TYPE_FLOAT : BOLD+BLUE,
    Bq.BTKN_TYPE_PATH : BOLD+YELLOW,
    Bq.BTKN_TYPE_URL : BOLD+YELLOW,
    Bq.BTKN_TYPE_WORD : BOLD,
    Bq.BTKN_TYPE_SEPARATOR : NORM,
    Bq.BTKN_TYPE_WHITESPACE : NORM,
    Bq.BTKN_TYPE_TEXT : BOLD+RED,
}

tkn_type_ids = {
    "TYPE" : Bq.BTKN_TYPE_TYPE,
    "PRIO" : Bq.BTKN_TYPE_PRIORITY,
    "VERS" : Bq.BTKN_TYPE_VERSION,
    "TS" : Bq.BTKN_TYPE_TIMESTAMP,
    "HOST" : Bq.BTKN_TYPE_HOSTNAME,
    "SVC" : Bq.BTKN_TYPE_SERVICE,
    "PID" : Bq.BTKN_TYPE_PID,
    "IP4" : Bq.BTKN_TYPE_IP4_ADDR,
    "IP6" : Bq.BTKN_TYPE_IP6_ADDR,
    "MAC" : Bq.BTKN_TYPE_ETH_ADDR,
    "HEX" : Bq.BTKN_TYPE_HEX_INT,
    "DEC" : Bq.BTKN_TYPE_DEC_INT,
    "SEP" : Bq.BTKN_TYPE_SEPARATOR,
    "FLOAT" : Bq.BTKN_TYPE_FLOAT,
    "PATH" : Bq.BTKN_TYPE_PATH,
    "URL" : Bq.BTKN_TYPE_URL,
    "WORD" : Bq.BTKN_TYPE_WORD,
    "SPACE" : Bq.BTKN_TYPE_WHITESPACE,
    "TEXT" : Bq.BTKN_TYPE_TEXT
}

def show_tkns(bs, args):
    if args.tkn_type:
        type_str = args.tkn_type.upper()
        if type_str in tkn_type_ids:
            tkn_type = tkn_type_ids[type_str]
        else:
            tkn = bs.tkn_by_name("_{0}_".format(type_str))
            if not tkn:
                raise NameError("{0} is an invalid type name".format(type_str))
            tkn_type = tkn.tkn_id()
            del tkn
    else:
        tkn_type = None

    ti = Bq.Btkn_iter(bs)
    print("{0:12} {1:32} {2:12} {3}".format(
        "Tkn Id", "Tkn String", "Tkn Seen", "Types"))
    hf = "{0} {1} {2} {3}".format(
        '-'.ljust(12, '-'), '-'.ljust(32, '-'), '-'.ljust(12, '-'),
        '-'.ljust(32, '-'))
    print(hf)
    tkn_count = 0
    for tkn in ti:
        if tkn_type and not tkn.has_type(tkn_type):
            continue
        tkn_count += 1
        print("{0:12} {1:32} {2:12}". \
              format(tkn.tkn_id(), tkn.tkn_str(), tkn.tkn_count()), end=' ')
        for typ in tkn:
            print("{0}".format(bs.tkn_type_str(typ)), end=' ')
        print("")
    print(hf)
    print("{0} Record(s)".format(tkn_count))

def fmt_comp_str(bs, comp_id, args):
    try:
        if args.raw_id:
            return str(comp_id)
        tkn = bs.tkn_by_id(comp_id)
        if tkn:
            return tkn.tkn_str()
        return str(comp_id)
    except:
        return str(comp_id)

def fmt_tkn_str(tkn, args):
    tkn_str = ""
    if args and args.color:
        if tkn.tkn_id() in type_colors:
            tkn_str = type_colors[tkn.tkn_id()]
        elif tkn.first_type() in type_colors:
            tkn_str = type_colors[tkn.first_type()]
    if tkn.tkn_id() == Bq.BTKN_TYPE_WHITESPACE:
        tkn_str += " "
    else:
        tkn_str += tkn.ptn_tkn_str()
    if args and args.color:
        tkn_str += RESET
    return tkn_str

def show_matching_ptns(bs, args):
    tkn_id = tkn_id_from_args(args)
    if not tkn_id:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --match")
    match_tkn = bs.tkn_by_id(tkn_id)

    pi = Bq.Bptn_iter(bs)
    start, end = get_times_from_args(args)
    do_header("{0:12} {1:12} {2:20} {3:20} {4}".format(
        "Ptn Id", "Msg Count", "First Seen", "Last Seen", "Pattern"), args)
    hf = "{0} {1} {2} {3} {4}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'), '-'.ljust(20, '-'),
        '-'.ljust(20, '-'), '-'.ljust(32, '-'))
    do_header(hf, args)

    pi.find(start)
    ptn_count = 0
    matching_cols = {}
    for p in pi:
        if end > 0 and p.first_seen() > end:
            break

        # For each position in the pattern.
        #   If the type in that position doesn't match any of the token's types,
        #     skip this position
        #   otherwise
        #     search the pattern's ptn_tkn index for the token
        #     if tkn is found
        #         save the position
        #
        ptn_match = False
        pos = 0
        for tkn in p:
            if 0 == (tkn.type_mask() & match_tkn.type_mask()):
                pos += 1
                continue

            if tkn.tkn_id() == tkn_id:
                ptn_tkn = tkn
            else:
                ptn_tkn = p.find_tkn(pos, tkn_id)
            if ptn_tkn:
                if not ptn_match:
                    cols = []
                    cols.append(pos)
                    matching_cols[p.ptn_id()] = cols
                    ptn_match = True
                    pos += 1
                else:
                    matching_cols[p.ptn_id()].append(pos)
            pos += 1

        if not ptn_match:
            # This pattern does not contain the match token
            continue

        ptn_count += 1
        print("{0:12} {1:12} {2:20} {3:20}". \
              format(p.ptn_id(), p.msg_count(),
                     fmt_tstamp(p.first_seen(), args),
                     fmt_tstamp(p.last_seen(), args)), end=' ')
        pos = 0
        cpos = 13 + 13 + 21 + 21
        matches = []
        for tkn in p:
            if pos in matching_cols[p.ptn_id()]:
                tkn_str = UNDERLINE + fmt_tkn_str(tkn, args) + RESET
                matches.append(cpos+len(fmt_tkn_str(tkn, None))/2)
                cpos = 0
            else:
                tkn_str = fmt_tkn_str(tkn, args)
            print("{0}".format(tkn_str), end='')
            cpos += len(fmt_tkn_str(tkn, None))
            pos += 1
        print("")
        if args.loc:
            for col in matches:
                print("^".rjust(col, " "), end='')
            print("")

    do_footer(hf, args)
    do_footer("{0} Record(s)".format(ptn_count), args)

def print_ptn(p, args):
    print("{0:12} {1:12} {2:20} {3:20}". \
          format(p.ptn_id(), p.msg_count(),
                 fmt_tstamp(p.first_seen(), args),
                 fmt_tstamp(p.last_seen(), args)), end=' ')
    for tkn in p:
        tkn_str = fmt_tkn_str(tkn, args)
        print("{0}".format(tkn_str), end='')
    print("")

def show_ptns(bs, args):
    pi = Bq.Bptn_iter(bs)
    start, end = get_times_from_args(args)
    do_header("{0:12} {1:12} {2:20} {3:20} {4}".format(
        "Ptn Id", "Msg Count", "First Seen", "Last Seen", "Pattern"), args)
    hf = "{0} {1} {2} {3} {4}".format(
        '-'.ljust(12, '-'), '-'.ljust(12, '-'), '-'.ljust(20, '-'), '-'.ljust(20, '-'),
        '-'.ljust(32, '-'))
    do_header(hf, args)
    ptn_count = 0
    msg_count = 0
    if args.ptn_id:
        # single pattern
        p = bs.ptn_by_id(args.ptn_id)
        if p:
            ptn_count += 1
            print_ptn(p, args)
            msg_count += p.msg_count()
    else:
        pi.set_filter(tv_begin=(start, 0), tv_end=(end, 0))
        id_set = util.IDSet(args.ptn_ids) if args.ptn_ids else None
        for p in pi:
            if end > 0 and p.first_seen() > end:
                continue
            if id_set and p.ptn_id() not in id_set:
                continue
            ptn_count += 1
            print_ptn(p, args)
            msg_count += p.msg_count()
    do_footer(hf, args)
    do_footer("{0} Patterns(s) {1} Messages(s)".format(ptn_count, msg_count), args)

def show_ptn_hist(bs, args):
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    start, end = get_times_from_args(args)

    phi = Bq.Bptn_hist_iter(bs)
    phi.set_filter(ptn_id=ptn_id, bin_width=bin_width, tv_begin=(start,0))

    if not args.csv:
        hf = "{0:12} {1:20} {2:12} {3:12}".format("Ptn Id", "Timestamp",
                                                  "Bin Width", "Msg Count")
        sep = "{0} {1} {2} {3}".format('-'.ljust(12,'-'), '-'.ljust(20,'-'),
                                       '-'.ljust(12,'-'), '-'.ljust(12,'-'))
        do_header(hf, args)
        do_header(sep, args)
    else:
        hf = "# {0},{1},{2},{3}".format("Ptn Id", "Timestamp",
                                        "Bin Width", "Msg Count")
        do_header(hf, args)

    msg_count = 0
    rec_count = 0
    phi.first()
    for h in phi:
        if end > 0 and h.time() > end:
            break
        if not args.csv:
            print("{0:12} {1:20} {2:12} {3:12}" \
                  .format(h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        else:
            print("{0},{1},{2},{3}" \
                  .format(h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        rec_count += 1
        msg_count += h.msg_count()
    if not args.csv:
        do_footer(sep, args)
        do_footer("{0:46} {1:12}".format("{0} Record(s)".format(rec_count),
                                         msg_count), args)

def show_tkn_hist(bs, args):
    tkn_id = tkn_id_from_args(args)
    if tkn_id is None:
        raise ValueError("The --tkn_id or --tkn_str arguments must be " \
                         "specified with --tkn")

    ti = Bq.Btkn_hist_iter(bs)
    start, end, bin_width = get_hist_args(ti, tkn_id, args)
    ti.set_filter(tkn_id=tkn_id, bin_width=bin_width, tv_begin=(start,0))
    if not args.csv:
        do_header("{0:12} {1:20} {2:20} {3:12} {4:12}"
                  .format("Tkn Id", "Tkn Text", "Timestamp",
                          "Bin Width", "Msg Count"), args)
        hf = "{0} {1} {2} {3} {4}".format('-'.ljust(12,'-'),
                                          '-'.ljust(20,'-'),
                                          '-'.ljust(20,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(12,'-'))
        do_header(hf, args)
    else:
        do_header("# {0},{1},{2},{3},{4}".format("Tkn Id", "Tkn Text", "Timestamp",
                                             "Bin Width", "Msg Count"), args)
    msg_count = 0
    rec_count = 0
    for h in ti:
        tkn = bs.tkn_by_id(h.tkn_id())
        if end > 0 and h.time() > end:
            break
        if not args.csv:
            do_header("{0:12} {1:20} {2:20} {3:12} {4:12}" \
                  .format(h.tkn_id(), tkn.tkn_str(),
                          fmt_tstamp(h.time(), args),
                          h.bin_width(), h.tkn_count()), args)
        else:
            print("{0},{1},{2},{3},{4}" \
                  .format(h.tkn_id(), tkn.tkn_str(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.tkn_count()))
        rec_count += 1
        msg_count += h.tkn_count()
    if not args.csv:
        do_footer(hf, args)
        do_footer("{0:46} {1:12}". \
                  format("{0} Record(s)". format(rec_count), msg_count), args)

def show_comp_hist(bs, args):
    start, end = get_times_from_args(args)
    if not args.ptn_id:
        ptn_id = 0
    else:
        ptn_id = args.ptn_id
    comp_id = tkn_id_from_args(args)
    if not comp_id:
        comp_id = 0
        # raise ValueError("The --comp_id or --comp_str arguments must be " \
        #                 "specified with --comp")
    if args.bin_width:
        bin_width = xlate_bin_width(args)
    else:
        bin_width = 3600        # hours

    chi = Bq.Bcomp_hist_iter(bs)
    chi.set_filter(comp_id=comp_id, ptn_id=ptn_id, bin_width=bin_width,
                   tv_begin=(start, 0))
    if not args.csv:
        do_header("{0:12} {1:12} {2:20} {3:12} {4:12}". \
                  format("Component", "Ptn Id", "Timestamp",
                         "Bin Width", "Msg Count"), args)
        hf = "{0} {1} {2} {3} {4}".format('-'.ljust(12,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(20,'-'), '-'.ljust(12,'-'),
                                          '-'.ljust(12,'-'))
        do_header(hf, args)
    else:
        do_header("# {0},{1},{2},{3},{4}". \
                  format("Component", "Ptn Id", "Timestamp",
                         "Bin Width", "Msg Count"), args)
    msg_count = 0
    rec_count = 0
    for h in chi:
        if end > 0 and h.time() > end:
            break
        comp_str = fmt_comp_str(bs, h.comp_id(), args)
        if not args.csv:
            print("{0:12} {1:12} {2:20} {3:12} {4:12}" \
                  .format(comp_str, h.ptn_id(),
                          fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        else:
            print("{0},{1},{2},{3},{4}" \
                  .format(h.comp_id(), h.ptn_id(), fmt_tstamp(h.time(), args),
                          h.bin_width(), h.msg_count()))
        rec_count += 1
        msg_count += h.msg_count()
    if not args.csv:
        do_footer(hf, args)
        do_footer("{0:59} {1:12}".format("{0} Record(s)". \
                                         format(rec_count), msg_count), args)

def valid_date(date_str):
    try:
        return dt.datetime.strptime(date_str, "%Y/%m/%d %H:%M")
    except:
        msg = "{0} is not a valid date".format(date_str)
        raise argparse.ArgumentTypeError(msg)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Query Baler data")
    parser.add_argument("-p", "--path", required=True,
                        help="The path to the Baler store")
    parser.add_argument("-m", "--msg", action="store_true",
                        help="Query messages")
    parser.add_argument("--begin", type=valid_date,
                        help="Specify the start time/date for the query. " \
                        "Format is YYYY/MM/DD HH:MM")
    parser.add_argument("--end", type=valid_date,
                        help="Specify the start time/date for the query. " \
                        "Format is YYYY/MM/DD HH:MM")
    parser.add_argument("--ptn", action="store_true",
                        help="Query patterns.")
    parser.add_argument("--comp", action="store_true",
                        help="Query component histories")
    parser.add_argument("--summary", action="store_true",
                        help="Show a summary of the database")
    parser.add_argument("--verbose", action="store_true",
                        help="Show more detailed summary information")
    parser.add_argument("--tkn", action="store_true",
                        help="Query tokens")
    parser.add_argument("--tkn_type",
                        help="Specifies the type of a token")
    parser.add_argument("--tkn_id", type=int,
                        help="Specifies the integer id for a token")
    parser.add_argument("--tkn_str",
                        help="Specifies the string value of a token.")
    parser.add_argument("--match", action="store_true",
                        help="Show the patterns that contain a token")
    parser.add_argument("--hist", action="store_true",
                        help="Query the occurance histogram for --tkn, --ptn, and --comp")
    parser.add_argument("--dist", action="store_true",
                        help="Query the disrtribution --tkn, --ptn, and --comp")
    parser.add_argument("--ptn_tkn", action="store_true",
                        help="Query the tokens that appear in a pattern")
    parser.add_argument("--ptn_id", type=int,
                        help="The pattern id.")
    parser.add_argument("--ptn_ids",
                        help="A comma separated list of pattern ids.")
    parser.add_argument("--comp_id", dest="tkn_id", type=int,
                        help="Specifies a component id")
    parser.add_argument("--comp_str", dest="tkn_str",
                        help="Specifies the component name")
    parser.add_argument("--bin_width", choices=['d', 'h', 'm'],
                        help="Specifies the histogram bin width")
    parser.add_argument("--color", action="store_true",
                        help="Set to color code tokens.")
    parser.add_argument("--csv", action="store_true",
                        help="Format the output as a comma separated text")
    parser.add_argument("--unix_time", action="store_true",
                        help="Format time as a Unix timestamp")
    parser.add_argument("--raw_id", action="store_true",
                        help="Show token id for component name instead of text")
    parser.add_argument("--plot", action="store_true",
                        help="Plot the data instead of displaying it as text")
    parser.add_argument("--label_size", type=int, default=9,
                        help="Specify the bar label font size")
    parser.add_argument("--y_scale", default='linear',
                        help="Specify the y-scale as 'log' or 'linear'")
    header = parser.add_mutually_exclusive_group(required=False)
    header.add_argument("--header", dest="header", action="store_true",
                        help="Enable table headers")
    header.add_argument("--no-header", dest="header", action="store_false",
                        help="Disable table headers")
    locator = parser.add_mutually_exclusive_group(required=False)
    locator.add_argument("--loc", dest="loc", action="store_true",
                        help="Put a ^ character beneath the matching " \
                         "token in a pattern")
    locator.add_argument("--no-loc", dest="loc", action="store_false",
                        help="Do not put a ^ character beneath the matching " \
                         "token in a pattern")
    parser.set_defaults(loc=True)
    parser.set_defaults(header=True)

    args = parser.parse_args()
    bs = Bq.Bstore()
    bs.open(args.path)

    if args.summary:
        show_summary(bs, args)

    if args.plot:
        import matplotlib.pyplot as plt
        import matplotlib.mlab as mlab
        import matplotlib.dates as mdates

    if args.tkn:
        if args.hist:
            if args.plot:
                plot_tkn_hist(bs, args)
            else:
                show_tkn_hist(bs, args)
        else:
            show_tkns(bs, args)

    if args.match and not args.ptn:
        print("The --match option is ignored without the --ptn option")

    if args.ptn:
        if args.hist:
            if args.plot:
                plot_ptn_hist(bs, args)
            else:
                show_ptn_hist(bs, args)
        elif args.dist:
            plot_ptn_dist(bs, args)
        elif args.match:
            show_matching_ptns(bs, args)
        else:
            show_ptns(bs, args)

    if args.comp:
        if not args.plot:
            show_comp_hist(bs, args)
        else:
            plot_comp_hist(bs, args)

    if args.ptn_tkn:
        show_ptn_tkns(bs, args)

    if args.msg:
        show_msgs(bs, args)
